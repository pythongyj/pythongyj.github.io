[{"title":"Vue字体图标不显示的设置","date":"2019-03-20T16:00:00.000Z","path":"2019/03/21/iconfont/","text":"elementUI字体图标不显示 完美解决方案使用vue init webpack-simple xxx 创建的项目 在使用ElementUI的时候使用 字体图标时提示 根据报错提示可以看出时无法处理element-icons.ttf文件 原因时什么呢？ 相信大家都能够知道，这是因为webpack不知道怎么去处理.ttf的文件 这个时候我们就需要url-loader来帮助我们处理.ttf字体文件 1//这个时候需要我们去执行npm命令去下载url-loader2npm/cnpm install url-loader --save 下载完成后 去过你尝试去npm run dev 你会发现还是报和上面相同的错误，这是为什么呢？ 答案当然是因为你没有使用这个加载器（url-loader） 现在就需要你在webpack.config.js中去配置 这个配置说句实在的让小编好为难，因为一开始的时候咱也不知道该怎么配置啊，怎么办呢？ 这个时候度娘就显现出来了强大的威力，我开始了百度，看到别人的博客，知道了在rules下配置如下信息 1&#123;2 test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,3 loader: 'url-loader',4&#125; 别急着运行你的项目———这里有坑 看图 此图 是配置信息 此图是运行结果 此时你会发现 不报错了 但是我的图标去哪了？ 当时的小编也不知道啊 可能是被外星人给叼走了 哈哈 开个玩笑 经过小编的不懈努力 至于找到了问题的所在 这个因为没有设置limit选项 你可能会问这是什么东东 别急 先来和小编一起看看文档 看图可以看出 是要设置文件的大小的 这个属性的默认值是undefined 当然 小编怕你有疑问 再给你贴出一副图 这上面详细写了各个选项的具体功能 此时的你 应该已经很明确了问题原因的所在 和解决的办法 此时 就来看看我们伟大的成就吧 看图 配置 再来看运行的结果 如图： 此时，问题就完美解决了 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.qcwy.org.cn/tags/javascript/"},{"name":"iconfont","slug":"iconfont","permalink":"http://www.qcwy.org.cn/tags/iconfont/"},{"name":"vue","slug":"vue","permalink":"http://www.qcwy.org.cn/tags/vue/"}]},{"title":"CommonJS, AMD, CMD的区别","date":"2018-08-15T10:54:07.000Z","path":"2018/08/15/amdcmdcom/","text":"CommonJS, AMD, CMD都是JS模块化的规范。CommonJS是服务器端js模块化的规范，NodeJS是这种规范的实现。AMD(异步模块定义)和CMD(通用模块定义)都是浏览器端js模块化的规范。RequireJS 遵循的是 AMD，SeaJS 遵循的是 CMD CommonJS（同步模块定义）一个单独的文件就是一个模块加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象所以，定义一个模块就是写一个新的js文件，但是最后要将文件的内容exports出来 如何定义模块和加载模块？ 1//定义一个module.js文件2var A = function() &#123;3 console.log('我是定义的模块');4&#125;5/* 6 * 导出这个模块7 * 1.第一种返回方式 module.exports = A; 8 * 2.第二种返回方式 module.exports.test = A9 * 3.第三种返回方式 exports.test = A;10 * 注意：module.exports导出方式 与 exports导出方式是有区别的11 * 具体区别详见其他文章12 */13exports.test = A;1415//再写一个dome.js文件，导入刚才定义好的模块16const module = require(\"./module\"); //加载这个模块 require中是导入模块的路径 前面的变量名自定义 代表的是导入模块所导出的对象1718/* 调用这个模块，不同的返回方式用不同的方式调用19 * 1.第一种调用方式 module();20 * 2.第二种调用方式 module.test();21 */22module.test();232425/* 26 * 接下来我们去执行这个文件，前提是你本地要安装node.js27 * 首先打开cmd, cd到这个文件所在的目录下,执行: node dome.js28 */29node dome.js30//输出结果：我是定义的模块 以上就是CommonJS规范下的模块定义与加载的形式 注意： CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作 ​ 因此 -&gt; 像Node.js比较适用CommonJS的原因在于：Node.js主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式 ​ 而 -&gt; 浏览器环境 则 不适合适用CommonJS，原因在于浏览器环境要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD CMD 解决方案 AMD（异步模块定义）**AMD规范通过define方法去定义模块，通过require方法去加载模块。RequireJS实现了这种规范 AMD只有一个接口：define(id?,dependencies?,factory); 它要在声明模块的时候制定所有的依赖(dep)，并且还要当做形参传到factory中。要是没什么依赖，就定义简单的模块（或者叫独立的模块 1//编写一个module1.js文件2//定义独立的模块3define(&#123;4 methodA: function() &#123;5 console.log('我是module1的methodA'); 6 &#125;,7 methodB: function() &#123;8 console.log('我是module1的methodB'); 9 &#125;10&#125;);1112//编写一个module2.js文件13//另一种定义独立模块的方式14define(function () &#123;15 return &#123;16 methodA: function() &#123;17 console.log('我是module2的methodA'); 18 &#125;,19 methodB: function() &#123;20 console.log('我是module2的methodB'); 21 &#125;22 &#125;;23&#125;);2425//编写一个module3.js文件26//定义非独立的模块（这个模块依赖其他模块）27define(['module1', 'module2'], function(m1, m2) &#123;28 return &#123;29 methodC: function() &#123;30 m1.methodA();31 m2.methodB();32 &#125;33 &#125;;3435&#125;);3637//再定义一个main.js，去加载这些个模块38require(['module3'], function(m3)&#123;39 m3.methodC();40&#125;);4142//我们在一个html文件中去通过RequireJS加载这个main.js43//等号右边的main指的main.js44&lt;script data-main=\"main\" src=\"require.js\"&gt;&lt;/script&gt;4546//浏览器控制台输出结果47我是module1的methodA48我是module2的methodB CMD（通用模块定义）CMD是SeaJS 在推广过程中对模块定义的规范化产出 AMD和CMD的区别： 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible（尽可能的懒加载，也称为延迟加载，即在需要的时候才加载）。 CMD 推崇依赖就近，AMD 推崇依赖前置。虽然 AMD 也支持 CMD 的写法，同时还支持将 require 作为依赖项传递，但 RequireJS 的作者默认是最喜欢上面的写法，也是官方文档里默认的模块定义写法。 AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。 注意：部分文章可能会在不就的将来更新 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"common.js","slug":"common-js","permalink":"http://www.qcwy.org.cn/tags/common-js/"},{"name":"cmd","slug":"cmd","permalink":"http://www.qcwy.org.cn/tags/cmd/"},{"name":"amd","slug":"amd","permalink":"http://www.qcwy.org.cn/tags/amd/"}]},{"title":"获取url的各个参数的值","date":"2018-05-12T03:33:07.000Z","path":"2018/05/12/qureyUrlParams/","text":"思路由于下面的代码用的是简写的方式 为了所有人都能看得懂 或者说即使看不懂 看到思路 根据思路也能实现、所以写了以下的个人思路 有不好的 请私信我 对于私信的人 感激不尽 因为的你私信会让小编更上一层楼 定义一个url地址（就是确定要 解析的url地址） 定义一个方法用来解析参数 方法：先创建一个对象，用于存放参数的键值对 方法：先判断传入的参数是否为空 为空 直接返回一个空对象，不为空 进行解析 方法：使用split方法把 ？ 符号之前的数据剔除 方法：使用split方法把数据以 &amp; 作为切割点 切割成数组 方法：使用forEach对切割好的数组进行遍历 方法：再次使用split方法 把遍历的每一项 以 = 进行分割 分割成的数组的第一项作为 key 属性 第二项作为 value 属性 存放到之前定义好的 空对象中 方法：返回这个对象 具体实现代码1// 定义一个需要传递的URL2 const url = 'https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;tn=baidu'3 /*4 * str =&gt;需要解析的url5 * 返回的是一个解析好的对象6 * &#123;7 f: \"8\"8 ie: \"utf-8\"9 rsv_bp: \"1\"10 tn: \"baidu\"11 &#125;12 */13 const qureyUrlParams = function (str) &#123;14 const objStr = &#123;&#125;15 str &amp;&amp; str.split('?')[1].split('&amp;').forEach(item =&gt; objStr[item.split('=')[0]] = item.split('=')[1]);16 return objStr17 &#125;18 console.log(qureyUrlParams(url)); 相信 以上面写的思路，大家都能看的非常明白 但是：小编觉得这不是最好的解决方案，最好的解决方案是用正则表达式来进行解析。 正则表达式 的解决方案 详见 小编的 正则表达式 里面的案例 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.qcwy.org.cn/tags/javascript/"}]},{"title":"前端规范","date":"2018-04-15T00:54:07.000Z","path":"2018/04/15/norm/","text":"前端规范 命名规则 头 : header 内容 : content/container 尾部 : footer 导航 : nav 侧栏 : sidebar 栏目 : column 外围盒子控制整体布局 : wrapper 左 右 中 : left / center / right 登录条 : loginbar 标志 : logo 广告 : banner 页面主题 : main 热点 : hot 新闻 : news 下载 : download 子导航 : subnav 菜单 : menu 子菜单 : submenu 搜索 : search 友情链接 : friendlink 页脚 : footer 版权 : copyright 滚动 : scroll 内容 : content 标签页 : tab 文章列表 : list 提示信息 : msg 小技巧 : tips 栏目标题 : title 加入 : joinus 指南 : guild 服务 : service 注册 : regsiter 状态 : status 投票 : vote 合作伙伴 : partner 注释的写法 1/*Footer Start*/2内容区3/*Footer End*/ id的命名 3.1 页面结果 容器 : container 页头 : header 内容 : content / container 页面主体 : main 页尾 : footer 导航 : nav 侧栏 : sidebar 栏目 : column 页面外围控制整体布局宽度 : wrapper 左右中 : left / right / center 3.2 导航 导航 : nav 主导航 : mainbav 子导航 : subnav 顶导航 : topnav 边导航 : sidebar 左导航 : leftsidebar 右导航 : rightsidebar 菜单 : menu 子菜单 : submenu 标题 : title 摘要 : summary 3.3 功能 标志 : logo 广告 : banner 登陆 : login 登录条 : loginbar 注册 : regsiter 搜索 : search 功能区 : shop 标题 : title 加入 : joinus 状态 : status 按钮 : btn 滚动 : scroll 标签页 : tab 文章列表 : list 提示信息 : msg 当前的 : current 小技巧 : tips 图标 : icon 注释 : note 指南 : guild 服务 : service 热点 : hot 新闻 : news 下载 : download 投票 : vote 合作伙伴 : partner 友情链接 : link 版权 : copyright css样式 4.1 重置默认样式 4.2 添加自定义全局样式 4.3 抽取文件定义单页面全局样式 4.3 样式定义规则 ： 重定义 &gt; 伪类 &gt; 自定义 （便于阅读） javascript 书写规范 5.1 书写过程 ：每行代码结束结构统一（有无分号-&gt;有的话，每行代码都应该有-&gt; eslint 设置规则，遵守即可）。防止代码冗余 | 与不小心造成与远程代码造成冲突 5.2 库的引入 ：根据项目需求，尽量的少引入。引入的时候，尽量使用按需引入，节省资源 5.3 变量命名规则 ：驼峰式命名法 5.4 类命名 : 首字母大写, 驼峰式命名 5.5 函数命名: 首字母小写驼峰式命名 5.6 命名语义化, 尽可能利用英文单词或其缩写 5.7 尽量避免使用存在兼容性及消耗资源的方法或属性, 比如eval() &amp;; innerText 5.8 后期优化中, JavaScript非注释类中文字符须转换成unicode编码使用, 以避免编码错误时乱码显示; 5.9 代码结构明了, 加适量注释. 提高函数重用率 5.10 注重 样式 结构 行为 相分离 图片规范 6.1 所有页面元素类图片均放入img文件夹 6.2 图片格式仅限于gif || png || jpg 6.3 命名全部用小写英文字母 || 数字 || _ 的组合,其中不得包含汉字 || 空格 || 特殊字符;尽量用易懂的词汇, 便于团队其他成员理解; 另, 命名分头尾两部分, 用下划线隔开, 比如ad_left01.gif || btn_submit.gif 6.4 在保证视觉效果的情况下选择最小的图片格式与图片质量, 以减少加载时间 6.5 尽量避免使用半透明的png图片(若使用, 请参考css规范相关说明) 6.6 运用css sprite技术集中小的背景图或图标, 减小页面http请求, 但注意, 请务必在对应的sprite psd源图中划参考线, 并保存至img目录下 注释规范 7.1 html注释: 注释格式&lt; !–这儿是注释–&gt;, ‘–’只能在注释的始末位置,不可置入注释文字区域 7.2 css注释: 注释格式 /*这儿是注释*/ 7.3 JavaScript注释, 单行注释使用’//这儿是单行注释’ ,多行注释使用 /* 这儿有多行注释 */ 结束语 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.qcwy.org.cn/tags/javascript/"}]},{"title":"微信小程序登录验证","date":"2018-04-15T00:54:07.000Z","path":"2018/04/15/login-wx/","text":"流程图在说怎么做之前，先看下这个流程图 思路看完这个流程图 ，相必大家已经很清楚了。 为了防止大家不太明白，再次给大家聊一下流程图 在授权之前，应该选判断是否已经授权。因为在别的地方已经授权了 已授权：直接跳过授权的过程，进行本该进行的操作 未授权：进如以下流程进行授权 获取用户信息。 由于用户信息是隐私为题，需要征求用户的同意。所以，把这一步放到第二步，而不是第三步。 用户同意获取用户信息：获取用户系信息 用户不同意获取用户信息：终止以下操作，返回最开始授权之前的页面 使用微信提供的API接口wx.login()，请求微信的服务器，获取code 成功：返回code 失败：返回错误信息 使用获取到的用户信息+code向公司的服务器发起获取Token的 接口 请求。服务器根据传递的数据进行判断 请求成功：返回token 和请求成功的 状态信息等 请求失败：返回失败的 错误信息 比如：code不一致等（后端程序员编写具体的接口返回内容） 当请求成功后，进行本地存储 ，并开始授权之前的操作 使用微信小程序提供的API接口，进行本地存储 以后再有地方需要token的地方，就会直接从本地获取Token，而无需再次进行用户授权","tags":[{"name":"小程序","slug":"小程序","permalink":"http://www.qcwy.org.cn/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"JavaScript正则表达式","date":"2018-02-15T12:33:07.000Z","path":"2018/02/15/RegExp/","text":"写在前面正则表达式是一种字符串规则，在很多处理字符串的场合能够发挥出不可估量的强大，比如表单验证，数据替换等等。作为一名程序员，不管是前端还是后端，都应该掌握这门技术。此文章是本人在学习正则表达式时的一些笔记，以及封装的一些比较常用且功能强大的函数。希望这篇文章能够帮助到其他的小伙伴。当然，可能有些封装的不尽完美，所以，不尽完美之处，还请请私信我。我们共同进步。 正则表达式 (基础部分) regular expression : RegExp 正则表达式 作用： 用来处理字符串的规则 只能处理字符串、 他是一个规则 可以验证字符串是否符合某个规则(test方法)，也可以把字符串中符合规则的内容捕获到(exec/match方法) 编写正则表达式 创建方式有两种 1//字面量的方式创建 (两个//之间包起来的都是用来描述正则规则的元字符)2let reg=/\\d+/;34//实例的方式 构造函数创建 两个参数： 一个是元字符字符串 修饰符字符串5let reg1=new RegExp('\\\\d+'); 正则表达式由两部分组成 元字符 修饰符 1/* 1. 常用的元字符*/23// ==&gt; 1.量词元字符 设置出现的次数4 // 1. * 0到多次5 // 2. + 1到多次6 // 3. ？ 0次 || 一次7 // 4. &#123;n&#125; 出现n次 n为大于0的正整数8 // 5. &#123;n,m&#125; 出现 n 到 m 次910/* 2.特殊元字符 ： 单个或者组合在一起代表特殊的含义*/11// 1. \\ 转义字符（普通字符-&gt;特殊-&gt;普通）12// 2. . 除\\n（换行符）以外的任意字符13// 3. ^ 以哪一个元字符作为开始（^看瑞特符号）14// 4. $ 以哪一个元字符作为结束15// 5. \\n 换行符16// 6. \\d 0~9之间的一个数字17// 7. \\D 非0~9之间的一个数字18// 8. \\w 数字、字母、下划线 中的任意一个字符19// 9. \\s 一个空白字符 （包含空格 制表符 换页符等）20// 10.\\t 一个制表符 （一个TAB键：4个空格）21// 11.\\b 匹配一个单词的边界22// 12.x|y x或者y中的一个字符23// 13.[xyz] x或者y或者z中的一个字符24// 14.[^xy] 除了x、y以外的字符25// 15.[a-z] 指定a到z这个范围中的任意字符 [0-9a-zA-Z_] === \\w26// 16.[^a-z] 15/条的取反27// 17.() 正则中的分组28// 18.(?:) 只匹配不捕获29// 19.(?=) 正向预查30// 20.(?!) 负向预查3132/* 3.普通元字符 ： 代表本身含义的 */33// /zhnegze/ 此正则匹配的就是 'zhengze' 修饰符 1/* 正则表达式常用的修饰符：i m g */2// 1. i ignoreCase (一个闹尅死) 忽略单词大小写匹配3// 2. m multiline（莫体力） 忽略换行匹配 能够多行匹配4// 3. g global (阁楼布偶) 全局匹配56// /A/.test('lalala'); ===&gt;false7// /A/i.test('lalala'); ===&gt;true 元字符详细解析 ^ 开头 $ 结尾 1let reg = /^\\d/ ; //任意数字开头2reg.test('hahaha'); //===&gt;false3reg.test('lalala123'); //===&gt;false4reg.test('20191101hah'); //===&gt;true 1let reg = /\\d$/ ; //任意数字结尾2reg.test('hahaha'); //===&gt;false3reg.test('lalala123'); //===&gt;true4reg.test('20191101hah'); //===&gt;false 1//两个都不加 : 字符串中包含符合规则的就可以2let reg = /\\d+/ ; //包含数字就可以3reg.test('hahaha'); //===&gt;false4reg.test('lalala123'); //===&gt;true5reg.test('20191101hah'); //===&gt;true67//两个都加 : 字符串只能和规则一致8let reg1 = /^\\d+$/; //之能是以数字开头 数字结尾 的数字910//验证手机号码11let reg2 = /^1\\d&#123;10&#125;$/;//只能以1开头 以数字结尾 中间是0~9之间的数 出现10次 \\ 1//把特殊符号转换为 普通 符号 x|y 1let reg1 = /^18|19$/;2reg.test('18'); //===&gt;true3reg.test('19'); //===&gt;true4reg.test('189'); //===&gt;true5reg.test('119'); //===&gt;true6reg.test('81'); //===&gt;false7reg.test('819'); //===&gt;true8//-------------直接使用会存在很乱的优先级问题 一般写的时候一般都伴随着（） 因为小括号会改变处理的优先级 --&gt; 小括号： 分组9let reg1 = /^18|19$/;10reg.test('18'); //===&gt;true11reg.test('19'); //===&gt;true12reg.test('189'); //===&gt;false [] 1//1.中括号中出现的字符一般都代表本身的含义2//2.中括号中不存在多位数 常用的正则表达式 常用的有效数字 1有效数字: 0 1 12 0.2 -1 -12.32 /*3 * 规则分析4 * 1.可能出现 - + 号5 * 2.一位0~9都可以，多位首位不能是06 * 3.小数部分可有可无，有的话必须有小数点和数字7 */8let reg = /^[+-]?(\\d|([1-9]\\d+))(\\.\\d+)?$/; 验证密码 1// 字母、数字、下划线2// 长度 ： 6~16位3let reg = /^\\w&#123;6,16&#125;$/; 4reg.test(val)//返回true代表符合规则 false不符合规则 验证真实姓名 1/*2 * 1.汉字 /^[\\u4E00-\\u9FA5]$/3 * 2.名字长度 2~104 * 3.可能有译名 XX·XXX '尼古·哈哈'5 * 4.可能有少数民族名字 2~106 */7let reg = /^[\\u4E00-\\u9FA5]&#123;2,10&#125;(·[\\u4E00-\\u9FA5]&#123;2,10&#125;)&#123;0,2&#125;$/; 验证邮箱 12/*3 * 1.@符号前 \\w+((-\\w+)|(\\.\\w+))*4 * 1.1.以数字 字母 下划线 开头 1到多位5 * 1.2.还可以是 - 数字 字母 下划线 或者 .数字 字母 下划线 整体出现 0 到 多次6 * 邮箱名：由 数字 字母 下划线 . - 组成 切必须以 数字 开头 -/. 不能连续出现7 * 2.[A-Za-z0-9]+ @xxx.com8 * 2.1.@后紧跟着 数字 字母 1到多位9 * 3.((\\.|-)[A-Za-z0-9]+)* xxx@xxx.[com].cn 匹配com 对@后面名字的补充10 * 3.1.11 * 4.\\.[A-Za-z0-9]+ .cn .com ...12 */13let reg = /^\\w+((-\\w+)|(\\.\\w+))*@[A-Za-z0-9]+((\\.|-)[A-Za-z0-9]+)*\\.[A-Za-z0-9]+$/; 身份证号码 1/*2 * 1.一共18位3 * 2.最后一位可能是X X代表的是104 * 身份证前六位意义： 省 市 县5 * 中间八位意义： 年 月 日6 * 最后四位意义： 最后一位 X或者数字 7 * 倒数第二位： 偶数是 女 基数是 男8 * 其余位数是经过算法算出来的9 */10//let reg = /^\\d&#123;17&#125;(\\d|X)$/;不用11//小括号作用 ： 1. 分组捕获 不仅可以把大正则匹配的信息捕获到，还可以单独捕获到每个小分组的内容 2.改变优先级12let reg = /^(\\d&#123;6&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d)(\\d|X)$/;13reg.exec('4114121198902034432') //捕获结果是一个数组 #### **正则表达式捕获的懒惰性** 实现正则捕获的方法 懒惰性的解决办法 正则RegExp.prototype上的方法 exec 1/*2 * 基于exec实现正则的捕获3 * 1. 捕获到的结果是null / 一个数组 第一项捕获到的是内容 其余项 对应小分组本次单独捕获到的内容 index项 当前捕获到的 在原字符串的起始索引 input项 原始字符串4 * 2.每执行一次 exec只能捕获到一个符合正则规则的 默认情况下 即使多次捕获 捕获的结果永远是第一个 即=&gt;正则的懒惰性 默认只捕获一个5 * 6 * lastIndex代表当前正则下一次匹配的起始索引位置 console.log(reg.lastIndex); ===0 7 * 正则懒惰性的原因就是因为lastIndex默认情况下是不会被修改/改变的 每次都是从起始位置开始查找 lastIndex不能手动修改不行 只能使用全局修饰符 g /\\d+/g 匹配后lastIndex值会自动改变 8 */ 1//需求：编写一个方法execAll()，执行一次可以把所有匹配的结果捕获到（前提：正则一定要设置全局修饰符 g）23function()&#123;4 function execAll(str)&#123;5 // str ： 是要匹配的字符串6 // this ：RegExp的实例（当前操作的正则）7 // 首先验证传进来的正则是否设置了全局修饰符 g 如果没有 则不进行捕获 8 if(!this.global) return this.exec(str);9 // arr : 存储最后所有捕获的信息10 // res ：存储每次捕获的内容 11 let arr = [];12 let res = this.exec(str);13 while(res)&#123;14 //把每次捕获的数组的第一项内容放到数组arr中15 arr.push(res[0]);16 //只要捕获的内容部位null 则继续捕获17 res = this.exec(str);18 &#125;19 return arr === 0 ？ null : arr;20 &#125;21 RegExp.prototype.execAll=execAll;22&#125;();23let reg = /\\d+/g;24console.log(reg.execAll(str)); test 字符串String.prototype上支持正则表达式处理的方法 replace match 1// 字符串.match(正则); 返回所有匹配的数 以数组的形式返回 即 返回 所有符合正则的 项 的数组 如果一项都没有匹配 则返回null2// match 可以在执行一次的情况下 捕获到所有匹配的数据 ( 前提 ：正则需要加全局修饰符 g )34// 上面那些代码 就是 match 实现原理 splite …… 1//实现正则匹配的前提是：当前正则要和字符串匹配 如果不匹配 （exec）捕获的是null 正则的分组捕获1/*2 * ?: =&gt;只匹配不捕获 如果设置了分组 又不想捕获到 就需要加 `？:` 来处理3 */4let reg=/^(\\d&#123;6&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)\\d&#123;2&#125;(\\d)(？:\\d|X)$/;5let str='411411199801224422';6console.log(str.match(reg)); 7//返回发结果 ：[\"411411199801224422\", \"411411\", \"1998\", \"01\", \"22\", \"2\", index: 0, input: \"411411199801224422\", groups: undefined] 1/* 2 * ===&gt; 获取自己想要的数据3 * 多次匹配时 只能捕获到大正则匹配到的数据 小分组的信息拿不到4 * 解决方案5 */6let str = '&#123;1993&#125;年&#123;03&#125;月&#123;23&#125;日';7let reg = /\\&#123;(\\d+)\\&#125;/g;8let aryBig = [];9let arySmall = [];10let res=reg.exec(str);11while(res)&#123;12 let [big,small] = res;13 aryBig.push(big);14 arySmall.push(small);15 res=res.exec(str);16&#125;17console.log(aryBig,arySmall);18// 执行结果为 ：aryBig==&gt;['&#123;1993&#125;','&#123;03&#125;','&#123;23&#125;'] arySmall==&gt;['1993','03','23'] 分组的第三个作用 : 分组引用 1// 分组的第三个作用 : 分组引用2let str = 'book'; //'good' 'look' 'moon' 'foot' ......3let reg = /^[a-zA-Z]([a-zA-Z])\\1[a-zA-Z]$/; //分组引用 ： 就是通过 '\\数字' 让其代表和对应分组出现一模一样的内容4console.log(reg.test('book'));//==&gt;true5console.log(reg.test('deep'));//==&gt;true6console.log(reg.test('some'));//==&gt;false 正则捕获的贪婪性1/*2 * =&gt;正则捕获的贪婪性 ：默认情况下 正则捕获的时候 是按照当前正则所匹配的最长结果来获取的3 * 4 */5let str = '啦啦啦2019&amp;&amp;加油2020';6let reg = /\\d+/g;7console.log(str.match(reg));//===&gt;[\"2019\", \"2020\"]89//----解决办法 ： ==&gt;在量词元字符后面加上一个 `？` 表示取消正则的贪婪性(按照正则匹配的最短结果来获取)----10let str = '啦啦啦2019&amp;&amp;加油2020';11let reg = /\\d+?/g;12console.log(str.match(reg));//[\"2\", \"0\", \"1\", \"9\", \"2\", \"0\", \"2\", \"0\"] ？在正则中的 五大作用 ?左边是非量词元字符 ：本身代表量词元字符 出现0到1次 ?左边是量词 元字符 ： 取消捕获时候的贪婪性 (?:) : 值匹配不捕获 (?=) : 正向预查 (?!) : 负向预查 其他正则捕获的方法 test也能捕获 (本意是匹配) 一般不用 了解就好 1let str = '&#123;2019&#125;年&#123;11&#125;月&#123;2日&#125;'；2let reg = /\\&#123;(\\d+)\\&#125;/g;3console.log(reg.test(str));//==&gt;true4console.log(RegExp.$1);//==&gt;201956console.log(reg.test(str));//==&gt;true7console.log(RegExp.$1);//==&gt;1189console.log(reg.test(str));//==&gt;true10console.log(RegExp.$1);//==&gt;21112console.log(reg.test(str));//==&gt;false13console.log(RegExp.$1);//==&gt;'2' 存储的是上次捕获的结果14//RegExp.$1~$9 : 获取当前本次正则匹配后 第一个到第九个分组的信息 replace 字符串中实现替换的方法 (一般都是伴随正则一起使用的) 重点 1let str = 'jiege@2019|jiege@2020';2// ==&gt;把 'jiege' 转换为 '杰哥'3// 1. 不使用正则 执行一次只能替换一个4str=str.replace('jiege','杰哥');5console.log(str);//==&gt;'杰哥@2019|jiege@2020'67//2. 使用正则 一次就可以完成所有匹配8str=str.replace(/jiege/g,'杰哥');9console.log(str);//==&gt;'杰哥@2019|杰哥@2020'1011// 必须使用正则 不然不好弄1213//不使用正则 每次替换从头开始 类似于正则的懒惰性14str=str.replace('jiege','jiegehaobang').replace('jiege','jiegehaobang');15console.log(str);//==&gt;'jiegehaobanghaobang@2019|jiege@2020'1617//使用正则18str=str.replace(/jiege/g,'jiegehaobang');19console.log(str);//==&gt;'jiegehaobang@2019|jiegehaobang@2020' 案例1：把时间字符串进行处理 1let time = '2019-11-02';2//变为 ==&gt; 2019年11月02日3let reg = /^(\\d&#123;4&#125;)-(\\d&#123;1,2&#125;)-(\\d&#123;1,2&#125;)$/;4time = time.replace(reg,'$1年$2月$3日');5console.log(time)//==&gt;\"2019年11月02日\" replace 实现原理 [str].replace([reg],[function]) 1let time = '2019-11-02';2//变为 ==&gt; 2019年11月02日3let reg = /^(\\d&#123;4&#125;)-(\\d&#123;1,2&#125;)-(\\d&#123;1,2&#125;)$/;45// 实现原理 [str].replace([reg],[function])6// 1.replace 首先拿reg和time进行匹配捕获，能匹配到几次就会把传递的函数执行几次 （而且是 匹配一次就执行一次）7// 2.不仅把方法执行了，而且replace还给方法传递了实参信息(是 exec捕获 的内容一致的信息：大正则匹配的信息 小分组匹配的系信息......)8// 3.在函数中 返回的是什么，就把当前大正则匹配的内容替换成什么910/*time = time.replace(reg,(big,$1,$2,$3)=&gt;&#123;11 //$1,$2,$3是自己设置的变量12 console.log(big,$1,$2,$3);//==&gt;2019-11-02 2019 11 0213&#125;)*/1415time = time.replace(reg,(...arg)=&gt;&#123;16 let [,$1,$2,$3]=arg;17 $2.length &lt; 2 ? $2 = `0$&#123;$2&#125;` : null;18 $3.length &lt; 2 ? $3 = `0$&#123;$3&#125;` : null;19 return `$&#123;$1&#125;年$&#123;$2&#125;月$&#123;$3&#125;日`20&#125;)21console.log(time);//==&gt;'2019年11月02日' 案例2：单词首字母大写 1let str = 'good good study,day day up!';2let reg = /\\b([a-zA-Z])[a-zA-Z]*\\b/g;3//=&gt;函数执行了6次，每一次都把正则匹配到的信息传递给函数4//=&gt;每一次arg存的都是一个数组：['good','g']......5str = str.replace(reg,(...arg)=&gt;&#123;6 let [content,$1]=arg;7 $1 = $1.toUpperCase();8 content = content.substring(1);9 return $1+content;10&#125;)11console.log(str); 案例3：验证一个字符串中那个字母出现的次数最多，多少次？ ​ 做法1： 1/*======去重思维=====*/2let str = '2019nianshayemeiganchneg';3//创建一个对象用来存放字符串的每一个不同的项4let obj = &#123;&#125;;5//将字符串中的每一项都放在对象中6[].forEach.call(str,char=&gt;&#123;7 //判断对象中有没有这个字符，有就把值加一 没有就赋值为一8 if(typeof obj[char]!=='undefined')&#123;9 obj[char]++;10 return;11 &#125;12 obj[char]=1;13&#125;)14let max = 1;15//储存次数最多的字符的数组16let res = [];17//判断出现次数最多的字符出现的次数18for(let key in obj)&#123;19 let item = obj[key];20 item &gt; max ? max = item : null;21&#125;22//判断出现次数最多的字符23for(let key in obj)&#123;24 let item = obj[key];25 if(item === max)&#123;26 res.push(key);27 &#125;28&#125;29console.log(res,max) //[\"n\"] 4 ​ 做法2： 1/*======排序=====*/2let str = '2019nianshayemeiganchnega';34str=str.split('').sort((a,b)=&gt;a.localeCompare(b)).join('');5console.log(str)//0129aaaceeegghhiimnnnnsy6let reg = /([a-zA-Z0-9])\\1+/g;7let ary = str.match(reg);8console.log(str.match(reg));//[\"aaaa\", \"eee\", \"gg\", \"hh\", \"ii\", \"nnnn\"]9ary.sort((a,b)=&gt;b.length - a.length);//sort()数组排序10console.log(ary.sort((a,b)=&gt;b.length - a.length));//[\"aaaa\", \"nnnn\", \"eee\", \"gg\", \"hh\", \"ii\"]11console.log(`出现最多的是$&#123;ary[0].slice(0,1)&#125;,出现了$&#123;ary[0].length&#125;`);//出现最多的是n,出现了412let max = ary[0].length;13let res = [ary[0].substr(0,1)];14for (let i = 1; i &lt; ary.length; i++) &#123;15 let item = ary[i];16 if (item.length&lt;max) &#123;17 break;18 &#125;19 res.push(item.slice(0,1));20&#125;21console.log(max,res); ​ 做法3：*代码最少 推荐 * 1/*======从最大到最小去找--正则匹配=====*/2let str = '2019nianshayemeiganchnega';34//把字符串变成数5str = str.split('').sort((a, b) =&gt; a.localeCompare(b)).join(''); //字母的比较不能用加减 只能用a.localeCompare(b)6//接收最大值7let max = 0;8let res = [];9let flag = false;10console.log(str); //0129aaaaceeegghhiimnnnnsy11for (let i = str.length; i &gt; 0; i--) &#123;12 let reg = new RegExp('([a-zA-Z])\\\\1&#123;' + (i - 1) + '&#125;', 'g');13 str.replace(reg, (content, $1) =&gt; &#123;14 res.push($1);15 max = i;16 flag = true;17 &#125;);18 if (flag) &#123;19 break;20 &#125;21&#125;22console.log(`出现次数最多的字符为$&#123;res&#125;,出现了$&#123;max&#125;次`); ​ 做法4：查找字母删减去重法 案例4：正则表达式 之 时间字符串格式化 1~ function () &#123;2 /**3 * formatTime:时间字符串的格式化处理方法4 * @param &#123;String&#125; templete 期望获取的日期格式模板5 * 模板规则：&#123;0&#125; -&gt;&#123;0~5&#125;-&gt;年月日时分秒6 * @returns &#123;String&#125; 格式化后的时间字符串7 */8 function formatTime(templete = '&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒') &#123;9 //先获取时间字符串中的年月日时分秒等信息10 let timeAry = this.match(/\\d+/g);11 console.log(timeAry); //[\"2019\", \"8\", \"13\", \"16\", \"51\", \"3\"]12 return templete = templete.replace(/\\&#123;(\\d+)\\&#125;/g, (content, $1) =&gt; &#123;13 //content : 代表当前本次大正则匹配的信息 $1代表小粉猪单独匹配的信息14 //以$1的值为索引，到timeary中找到对应的时间(如果没有 用'00'代替)15 let time = timeAry[$1] || '00';16 time.length &lt; 2 ? time = `0$&#123;time&#125;` : null;17 return time;18 &#125;);19 &#125;20 /* 扩展到内置类String.prototype上 */21 ['formatTime'].forEach(item =&gt; &#123;22 String.prototype[item] = eval(item);23 &#125;)24&#125;();2526let time = '2019-8-13 16:51:3';27// 服务器获取的时间数据 ：2019-8-13 16:51:3 2019/8/13 16:51:328// 想要转变的格式 ：'08月13日 16时51分' '2019年08月13日' ......2930// 如果想要[time.formatTime()]这样调用，则方法必须在字符串的原型上31time.formatTime();32time.formatTime('&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日'); //\"2019年08月13日\"33time.formatTime('&#123;0&#125;/&#123;1&#125;/&#123;2&#125;');//\"2019/08/13\"34time.formatTime('&#123;0&#125;-&#123;1&#125;-&#123;2&#125; &#123;3&#125;:&#123;4&#125;:&#123;5&#125;');//\"2019-08-13 16:51:03\" ​ 案例4：正则表达式之qureyURLParams 1~ function () &#123;2 /**3 * qureyURLParams:获取url地址问号后面的参数系信息（可能包含hash值）4 * @param5 * @return6 * [object]把所有问号参数信息以键值对的方式存储起来并返回7 */8 function qureyURLParams() &#123;9 let obj = &#123;&#125;;10 this.replace(/([^=#&amp;?]+)=([^=#&amp;?]+)/g, (...[, $1, $2]) =&gt; obj[$1] = $2);11 this.replace(/#([^=#&amp;?]+)/g, (...[, $1]) =&gt; obj['HASH'] = $1);12 return obj;13 &#125;14 /* 扩展到内置类String.prototype上 */15 ['qureyURLParams'].forEach(item =&gt; &#123;16 String.prototype[item] = eval(item);17 &#125;)18&#125;();1920let url = 'https://www.baidu.com/s?wd=dnf&amp;rsv_spt=1';21url.qureyURLParams(); ​ 案例4：正则表达式之千分符 1~ function () &#123;2 /**3 * millimeter:实现大数字的千分符处理4 * @param5 * @return6 * [String] 千分符后的字符串7 */8 function millimeter() &#123;9 return this.replace(/\\d&#123;1,3&#125;(?=(\\d&#123;3&#125;)+$)/g, content =&gt;content + ',');10 &#125;11 /* 扩展到内置类String.prototype上 */12 ['millimeter'].forEach(item =&gt; &#123;13 String.prototype[item] = eval(item);14 &#125;)15&#125;();1617let num = '123445112'; //=&gt;'112,212,323,123'18num.millimeter(); 注意：部分文章可能会在不就的将来更新 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.qcwy.org.cn/tags/javascript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://www.qcwy.org.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"盒子的垂直水平居中的几种方式","date":"2018-02-14T16:00:00.000Z","path":"2018/02/15/divCenter/","text":"准备工作首先，在做之前，咱们先来分析一下我们要做的是什么？ 一个盒子，垂直 水平 居中 首先 有居中 就必定会被一个父容器（盒子）包裹。 其次 要居中的盒子不会超出父容器大小（否则做居中意义就不大了） 然后 要居中的盒子的宽高可以分为两类 1. 具有固定的宽高。 2. 没有固定的宽高 ​ 根据盒子的类型也可分为两类 1.行内快元素inline-block 2. 块级元素block 那么 现在开始吧！ 方式一 (弹性盒模型的方式)html 代码 1&lt;div class=\"box\"&gt;2 &lt;div class=\"container\"&gt;&lt;/div&gt;3&lt;/div&gt; css 代码 1.box&#123;2 height: 100vh;3 display: flex;4 justify-content: center;5 align-items: center;6&#125;7.container&#123;8 width: 200px;9 background-color: aqua;10 height: 200px;11&#125; 效果图 方式二 （绝对定位）html 代码 1&lt;div class=\"box\"&gt;2 &lt;div class=\"container\"&gt;&lt;/div&gt;3&lt;/div&gt; css 代码 1.container &#123;2 width: 200px;3 background-color: red;4 height: 200px;5 margin: auto;6 position: absolute;7 top: 0;8 bottom: 0;9 left: 0;10 right: 0;11&#125; 效果图 注意：由于是使用绝对定位。元素脱离文档流，相对于具有除去static定位以外的其他父级定位去定位的，如果没有父级定位，根据body来定位 方式三（位移transform的translate属性 + 定位）html 代码 1&lt;div class=\"box\"&gt;2 &lt;div class=\"container\"&gt;&lt;/div&gt;3&lt;/div&gt; css代码 1body &#123;2 position: relative;3 height: 100vh;4&#125;56.container &#123;7 width: 200px;8 height: 200px;9 position: absolute;10 top: 50%;11 left: 50%;12 transform: translate(-50%, -50%);13 background-color: blueviolet;14&#125; 效果图 方式四（位移+外边距 + vh）html 代码 1&lt;div class=\"container\"&gt;&lt;/div&gt; css 代码 1.container &#123;2 width: 200px;3 height: 200px;4 margin: 0 auto;5 margin-top: 50vh;6 background-color: blanchedalmond;7 transform: translate(0, -50%)8&#125; 效果图 注意：部分文章可能会在不就的将来更新 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"html，css","slug":"html，css","permalink":"http://www.qcwy.org.cn/tags/html%EF%BC%8Ccss/"}]},{"title":"JavaScript原型","date":"2017-09-12T13:33:07.000Z","path":"2017/09/12/prototype/","text":"总结 原型对象 对象原型 构造函数 之间的关系 以及js的原型链问题这个只是点，想必每个前端程序员都会。具体的不再这多说，请往下看 原型对象 prototype 是构造函数的属性，这个属性是一个对象，称为原型对象 每个函数都有一个prototype原型对象 作用：共享方法，达到节省内存的目的。 如果不共享方法，每次实例化对象就得创建原型链上的所有的方法，浪费内存 对象原型 简称原型 ptoto 作用：指向原型对象 只读属性 只是提供对象的查找机制 每一个对象都有一个原型，作用是指向原型对象prototype 构造函数 constructor 作用：记录是哪个构造函数创建出来的 指向构造函数本身 用来让原型对象重新指向原来的构造函数 ​ js原型链 js的原型链就是js的一个查找规则查找的规则就如上图所属那样通过原型对象 一直往上查找js可以通过原型链 一级一级的向上查找， 直到查找到为止，原型链的最终指向为 null 注意：部分文章可能会在不就的将来更新 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.qcwy.org.cn/tags/javascript/"}]},{"title":"块级格式化上下文","date":"2017-09-12T13:33:07.000Z","path":"2017/09/12/block/","text":"块级格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域 根据MDN官网介绍 下列方式会创建块格式化上下文： 根元素(&lt;html&gt;) 浮动元素（元素的 float 不是 none） 绝对定位元素（元素的 position 为 absolute 或 fixed） 行内块元素（元素的 display 为 inline-block） 表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值） 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值） 匿名表格单元格元素（元素的 display为 table、``table-row、 table-row-group、``table-header-group、``table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table） overflow 值不为 visible 的块元素 display 值为 flow-root 的元素 contain 值为 layout、content或 paint 的元素 弹性元素（display为 flex 或 inline-flex元素的直接子元素） 网格元素（display为 grid 或 inline-grid 元素的直接子元素） 多列容器（元素的 column-count 或 column-width 不为 auto，包括 ``column-count 为 1） column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。 浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠也只会发生在属于同一BFC的块级元素之间 总结： BFC是一个独立的渲染区域，他规定了在该区域中，常规流块盒的布局 独立=&gt;不同的BFC区域，它们进行渲染的时候 互不干扰 创建了BFC的元素，隔绝了它内部与外部的联系，内部的渲染不会影响到外部 具体规则： ​ 创建BFC的元素：它的自动高度需要计算浮动元素 ​ 创建BFC的元素：它的边框盒不会与浮动元素重叠 ​ 创建BFC的元素：不会和它的子元素进行外边距合并 对于这些规则，下面会使用具体例子加以说明。 这个区域由某个HTML元素创建，常用的 常见的 会在内部创建BFC区域的元素： 根元素（html） 浮动，绝对定位，固定定位元素 overflow不等于visible的块盒 例子 一 自动高度需要计算浮动元素css代码 1.container&#123;2 background-color: beige;3 &#125;4 .item&#123;5 float: left;6 width: 200px;7 height: 200px;8 margin: 20px;9 background-color: red;10 &#125; html代码 1&lt;body&gt;2 &lt;div class=\"container\"&gt;3 &lt;div class=\"item\"&gt;&lt;/div&gt;4 &lt;div class=\"item\"&gt;&lt;/div&gt;5 &lt;div class=\"item\"&gt;&lt;/div&gt;6 &lt;div class=\"item\"&gt;&lt;/div&gt;7 &lt;div class=\"item\"&gt;&lt;/div&gt;8 &lt;div class=\"item\"&gt;&lt;/div&gt;9 &lt;div class=\"item\"&gt;&lt;/div&gt;10 &lt;div class=\"item\"&gt;&lt;/div&gt;11 &lt;div class=\"item\"&gt;&lt;/div&gt;12 &lt;div class=\"item\"&gt;&lt;/div&gt;13 &lt;/div&gt;14&lt;/body&gt; 可以看出，此时类为container的容器的高度为0，这也就是因为浮动脱离的文档流，形成了BFC，而常规流块盒不会计算浮动元素的高度。 造成了高度坍塌的问题 解决的办法有两个思路（注意：是两个思路，而不是两种解决办法） 使用clear+伪类的方法清除浮动，也就是在最后面添加一个元素清除浮动，撑开元素的高度 css代码 1 .container&#123;2 background-color: beige;3 &#125;45 .item&#123;6 float: left;7 width: 200px;8 height: 200px;9 margin: 20px;10 background-color: red;11 &#125;1213+ .clearfix::after&#123;14 content: \"\";15 display: block;16 clear: both;17 &#125; html代码 1&lt;body&gt;2+ &lt;div class=\"container clearfix\"&gt;3 &lt;div class=\"item\"&gt;&lt;/div&gt;4 &lt;div class=\"item\"&gt;&lt;/div&gt;5 &lt;div class=\"item\"&gt;&lt;/div&gt;6 &lt;div class=\"item\"&gt;&lt;/div&gt;7 &lt;div class=\"item\"&gt;&lt;/div&gt;8 &lt;div class=\"item\"&gt;&lt;/div&gt;9 &lt;div class=\"item\"&gt;&lt;/div&gt;10 &lt;div class=\"item\"&gt;&lt;/div&gt;11 &lt;div class=\"item\"&gt;&lt;/div&gt;12 &lt;div class=\"item\"&gt;&lt;/div&gt;13 &lt;/div&gt;14&lt;/body&gt; 效果： 使用创建BFC区域，因为BFC会计算浮动元素。即 只要能创建BFC都可以解决 根据不同的场景使用不同的方法 这里只是随便列举一个方法 css代码 1.container&#123;2 background-color: beige;3+ position: absolute;4+ /* overflow: hidden;这种方式副作用最小 */5+ /* float: left; */6&#125;7 8.item&#123;9 float: left;10 width: 200px;11 height: 200px;12 margin: 20px;13 background-color: red;14&#125; html代码 1&lt;body&gt;2- &lt;div class=\"container\"&gt;3 &lt;div class=\"item\"&gt;&lt;/div&gt;4 &lt;div class=\"item\"&gt;&lt;/div&gt;5 &lt;div class=\"item\"&gt;&lt;/div&gt;6 &lt;div class=\"item\"&gt;&lt;/div&gt;7 &lt;div class=\"item\"&gt;&lt;/div&gt;8 &lt;div class=\"item\"&gt;&lt;/div&gt;9 &lt;div class=\"item\"&gt;&lt;/div&gt;10 &lt;div class=\"item\"&gt;&lt;/div&gt;11 &lt;div class=\"item\"&gt;&lt;/div&gt;12 &lt;div class=\"item\"&gt;&lt;/div&gt;13 &lt;/div&gt;14&lt;/body&gt; 效果： 例子 二 BFC边框盒不会与浮动元素重叠BFC不会与浮动元素的边框盒重叠，这样会方便我们做很多布局，例如： css代码 1.float&#123;2 width: 200px;3 height: 200px;4 margin: 20px;5 background-color: red;6 float: left;7 &#125;89 .container&#123;10 height: 300px;11 background-color: #008c8c;12 /* overflow: hidden; */13 &#125; html代码 1&lt;body&gt;2 &lt;div class=\"float\"&gt;&lt;/div&gt;3 &lt;div class=\"container\"&gt;&lt;/div&gt;4&lt;/body&gt; 效果： 当把overflow: hidden;的注释打开时，就会在内部创建BFC，渲染的效果如下： 此时如果设置BFC的左外边距的话，只要外边距不超过左边浮动盒子的大小，就是无效的。 因为此时设置做外边距会被左边的浮动元素覆盖。 如果要设置两个盒子的间距的话，需要设置左边浮动盒子的右外边距 margin-right: 100px; 设置后效果如下 根据这个效果，可以做很多一边固定一边自适应的布局，也可以做多边固定，一边自适应。比如：圣杯布局，双飞翼布局，都可以使用这个特性进行布局。","tags":[{"name":"css","slug":"css","permalink":"http://www.qcwy.org.cn/tags/css/"}]},{"title":"Html基础知识学习总结","date":"2017-08-15T10:54:07.000Z","path":"2017/08/15/starthtml/","text":"Html基础知识学习总结Html基础标签 &lt;h1&gt;&lt;/h1&gt;:标题&lt;p&gt;&lt;/p&gt; 段落&lt;hr&gt;水平线&lt;br&gt;换行&lt;span&gt;&lt;/span&gt;分区，可多标签一行&lt;div&gt;&lt;/div&gt;分区，每个标签一行 文本格式化标签 加粗 斜体 删除 &lt;/ins 下划线 图像标签 属性 alt 图片不能显示时的替代文本 title 鼠标悬停时显示 height 图像高度 width 图像宽度 border 图像边框宽度 超链接标签 href =url 链接的地址target _blank 新窗口打开 &lt;base&gt; &lt;base target=&quot;_blank&quot;&gt; 设置超链接的共有属性 预格式化文本 &lt;pre&gt; &lt;/pre&gt; 预格式化文本 保留空格与换行 常用特殊字符1空字符 &amp;nbsp;2注册商标 &amp;reg;3&lt; &amp;lt;4&gt; &amp;gt; 5&amp; &amp;amp; 表格表格数据格式1&lt;body&gt;2&lt;!-- 表格标签--&gt;3 &lt;table border=\"1\"&gt;4 &lt;!--表格标题标签 即表头--&gt;5 &lt;caption&gt;表格标题&lt;/caption&gt;6 &lt;!--行标签--&gt;7 &lt;tr&gt;8 &lt;!--表头单元格,文字居中且加粗--&gt;9 &lt;th&gt;&lt;/th&gt;10 &lt;/tr&gt;11 &lt;tr&gt;12 &lt;!--单元格标签--&gt;13 &lt;td&gt;&lt;/td&gt;14 &lt;/tr&gt;15 &lt;/table&gt;16&lt;/body&gt; 表格属性 border 边框width 宽度height 高度align 设置表格在网页中水平对齐方式 left center right cellspacing 单元格与单元格之间距离 cellpadding 单元格内容与边框的距离 合并单元格行 rowspan=”合并单元格的个数 “ 列 colspan=”合并单元格个数” 合并的方式 先确认跨行还是跨列 根据 先上 后下 先左 后右的原则找到目标单元格 ，然后写上合并方式 和合并数量 删除多余的单元格 语义化结构划分1&lt;thead&gt;&lt;/thead&gt; 表的头部 内部必须拥有&lt;tr&gt;标签2&lt;tbody&gt;&lt;/tbody&gt; 表的主体3&lt;tfoot&gt;&lt;/tfoot&gt; 表的末尾4 注意：结构不是必须的 即使不写，绝大多数浏览器在解析的时候，都会智能的给你加上 列表分类 有序列表 无序列表 自定义列表 有序列表1&lt;ol&gt;2 &lt;li&gt;列表项&lt;/li&gt;3 &lt;li&gt;列表项&lt;/li&gt;4&lt;/ol&gt;5注意：实际中很少使用有序列表，在做一些列表的时候，大家都比较喜欢使用无序列表。因为ul标签里面只能嵌套li标签6 一般在使用列表的时候都会去除别表的默认样式，再根据自己的需求去使用css js 去定制自己需要的样式和交互 无序列表1&lt;ul&gt;2 &lt;!--ul内只能嵌套li--&gt;3 &lt;li&gt;列表项1 &lt;/li&gt;4 &lt;li&gt;列表项2&lt;/li&gt;5&lt;/ul&gt;6注意：一般的列表，都喜欢使用 无序列表 自定义列表1&lt;dl&gt;2 &lt;dt&gt;名词&lt;/dt&gt;3 &lt;dd&gt;名词的解释1&lt;/dd&gt;4 &lt;dd&gt;名词的解释2&lt;/dd&gt;5 &lt;dt&gt;名词2&lt;/dt&gt;6 &lt;dd&gt;名词2的解释2&lt;dd&gt;7&lt;/dl&gt;8注意：自定义标签一般都用在页面结尾的友情链接部分 就是 页面的 footer部分 表单 这里写具体的表单标签 // from表单用于提交数据 有action method name属性 表单标签 标签 语法&lt;input type=&quot;属性值&quot;/&gt; 属性值 type text 单行文本输入框 password 密码输入框 radio 单选按钮 checkbox 复选框 button 普通按钮 submit 提交按钮 reset 重置按钮 image 图像形式的提交按钮 file 文件域 name 控件的名称 value input控件中的默认文本值 size input控件在页面中的显示宽度 checked 表示默认选中状态 &lt;label&gt;&lt;/label&gt;标签 用户名： 用户名： &lt;textarea&gt;&lt;/textarea&gt; 文本域select下拉列表1&lt;select&gt;2 &lt;option&gt;--请选择--&lt;/option&gt;3 &lt;!--添加默认选中项--&gt;4 &lt;option selected=\"selected\"&gt;选项１&lt;/option&gt;5 &lt;option&gt;选项２&lt;/option&gt;6&lt;/select&gt; 注意：部分文章可能会在不就的将来更新 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"html","slug":"html","permalink":"http://www.qcwy.org.cn/tags/html/"}]}]