[{"title":"nuxt-i18n 国际化","date":"2020-07-07T14:54:07.000Z","path":"2020/07/07/nuxt-i18n/","text":"前言 ​ 由于本人的能力有限，如若有说得做的不对的地方，还望指出。当然，如若你有更好的方法，或者更优解，还望不吝赐教。 1、需求 根据需求，现在需要做一个服务端渲染的PC网站。SSR 技术选型：Vue Vue-i18n Nuxt.js elementUI 2、对于Vue-i8n在Nuxt.js中的使用 首先说一下，nuxt.js和我们之前做的SPA单页面应用不一样，做国际化也不一样，之前已经写过在SPA中如何使用国际化，现在再写一下在SSR中如何使用国际化 3、安装vue-i18n1npm install vue-i18n --save2yarn add vue-i18n --save 4、在nuxt中引入vue-i18n 在plugins文件夹下创建一个i18n.js文件，并写入如下代码 1import Vue from 'vue'2import VueI18n from 'vue-i18n'34Vue.use(VueI18n)56export default (&#123; app, store &#125;) =&gt; &#123;7 app.i18n = new VueI18n(&#123;8 locale: store.state.locale,9 fallbackLocale: 'zh-CN', // 我这里默认语言为中文10 messages: &#123;11 'en-US': require('@/locales/en-US.json'),12 'zh-CN': require('@/locales/zh-CN.json'),13 &#125;,14 &#125;)1516 app.i18n.path = (link) =&gt; &#123;17 // 如果是默认语言，就省略18 if (app.i18n.locale === app.i18n.fallbackLocale) &#123;19 return `/$&#123;link&#125;`20 &#125;21 return `/$&#123;app.i18n.locale&#125;/$&#123;link&#125;`22 &#125;23&#125; 5、在vuex中保存语言的状态 在store页面下创建一个index.js文件 注意： ​ nuxt.js中如果想要使用vuex的模块化功能，需要使用如下方法，nuxt会自动生成模块化的vuex。 ​ 如果不实用模块化，则和vuex的使用没有任何区别 1export const state = () =&gt; (&#123;2 locales: ['zh-CN', 'en-US'],3 locale: '',4&#125;)56export const mutations = &#123;7 // 此处为设置locale8 SET_LANG(state, locale) &#123;9 if (state.locales.includes(locale)) &#123;10 state.locale = locale11 &#125;12 &#125;,13&#125; 6、在middleware文件夹下新建i18n.js文件用来控制语言的切换 middleware中间件 1export default function (&#123;2 isHMR,3 app,4 store,5 route,6 params,7 error,8 redirect,9&#125;) &#123;10 const defaultLocale = app.i18n.fallbackLocale11 // If middleware is called from hot module replacement, ignore it12 if (isHMR) return13 // Get locale from params14 const locale = params.lang || defaultLocale15 if (!store.state.locales.includes(locale)) &#123;16 return error(&#123; message: 'This page could not be found.', statusCode: 404 &#125;)17 &#125;18 // Set locale19 store.commit('SET_LANG', locale)20 app.i18n.locale = store.state.locale21 // If route is /&lt;defaultLocale&gt;/... -&gt; redirect to /...22 if (23 locale === defaultLocale &amp;&amp;24 route.fullPath.indexOf('/' + defaultLocale) === 025 ) &#123;26 const toReplace =27 '^/' +28 defaultLocale +29 (route.fullPath.indexOf('/' + defaultLocale + '/') === 0 ? '/' : '')30 const re = new RegExp(toReplace)31 return redirect(route.fullPath.replace(re, '/'))32 &#125;33&#125; 7、在nuxt.config.js文件中进行配置 在上面写好之后，需要在这里进行配置才可以使用 1export default &#123;2 /*3 ** Nuxt rendering mode4 ** See https://nuxtjs.org/api/configuration-mode5 */6 mode: 'universal',7 /*8 ** Nuxt target9 ** See https://nuxtjs.org/api/configuration-target10 */11 target: 'server',12 /*13 ** Headers of the page14 ** See https://nuxtjs.org/api/configuration-head15 */16 head: &#123;17 title: process.env.npm_package_name || '',18 meta: [19 &#123; charset: 'utf-8' &#125;,20 &#123; name: 'viewport', content: 'width=device-width, initial-scale=1' &#125;,21 &#123;22 hid: 'description',23 name: 'description',24 content: process.env.npm_package_description || '',25 &#125;,26 ],27 link: [28 &#123; rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' &#125;,29 &#123;30 rel: 'stylesheet',31 href: '//at.alicdn.com/t/xxx.css',32 &#125;,33 ],34 // 头部内容、35 &#125;,36 /*37 ** Global CSS38 */39 css: ['element-ui/lib/theme-chalk/index.css', '@/assets/public.less'],40 /*41 ** Plugins to load before mounting the App42 ** https://nuxtjs.org/guide/plugins43 */44 plugins: [45 &#123; src: '@/plugins/element-ui', ssr: true &#125;,46 '~/plugins/axios',47+ '@/plugins/i18n.js',48 ],4950 router: &#123;51+ middleware: 'i18n',52 &#125;,53 generate: &#123;54 // 这里是指定生成静态文件的路由55+ routes: ['/', '/about', '/zh-CN', '/zh-CN/about'],56 &#125;,57 /*58 ** Auto import components59 ** See https://nuxtjs.org/api/configuration-components60 */61 components: true,62 /*63 ** Nuxt.js dev-modules64 */65 buildModules: [66 // Doc: https://github.com/nuxt-community/eslint-module67 '@nuxtjs/eslint-module',68 ],69 /*70 ** Nuxt.js modules71 */72 modules: ['@nuxtjs/axios'],73 /**74 * axios 代理75 */76 axios: &#123;77 prefix: '/api',78 credentials: true,79 proxy: true,80 &#125;,81 proxy: &#123;82 '/api': &#123;83 target: 'xxxx',84 pathRewrite: &#123;85 '^/api/': '/',86 &#125;,87 changeOrigin: true,88 &#125;,89 &#125;,90 /*91 ** Build configuration92 ** See https://nuxtjs.org/api/configuration-build/93 */94 // build: &#123;95 // transpile: [/^element-ui/],9697 // &#125;,98 build: &#123;99 vendor: ['element-ui'],100 babel: &#123;101 plugins: [102 [103 'component',104 &#123;105 libraryName: 'element-ui',106 styleLibraryName: 'theme-chalk',107 &#125;,108 ],109 ],110 comments: true,111 &#125;,112 &#125;,113&#125; 8、创建本地语言包 ​ 根据自己不同的需求，创建不同的语言包，这里只展示一个语言包 ​ 新建 local文件夹，创建en-US.json文件 1&#123;2 \"links\": &#123;3 \"home\": \"Home\",4 \"about\": \"About\",5 \"english\": \"English\"6 &#125;,7 \"home\": &#123;8 \"index\": \"index\",9 \"search\": \"searchs\",10 \"title\": \"hahah\"11 &#125;,12 \"about\": &#123;13 \"title\": \"About\"14 &#125;15&#125; 9、在page文件夹下创建页面文件 在page页面文件夹下创建_lang文件夹。lang前面的下划线是动态路由的意思，nuxt.js的router路由文件会根据page文件夹自动生成对应的路由文件 下面代码是切换语言的文件代码 创建page/_lang/index.vue 1&lt;template&gt;2 &lt;el-container class&#x3D;&quot;bv-example-row main&quot;&gt;3 &lt;NuxtLink4 v-if&#x3D;&quot;$i18n.locale &#x3D;&#x3D;&#x3D; &#39;zh-CN&#39;&quot;5 :to&#x3D;&quot;&#123; name: &#39;lang&#39;, params: &#123; lang: &#39;en-US&#39; &#125; &#125;&quot;6 class&#x3D;&quot;Header__Link&quot;7 active-class&#x3D;&quot;none&quot;8 exact9 &gt;10 en&#123;&#123; $t(&#39;links.english&#39;) &#125;&#125;11 &lt;&#x2F;NuxtLink&gt;1213 &lt;NuxtLink14 v-else15 :to&#x3D;&quot;&#123; name: &#39;lang&#39;, params: &#123; lang: &#39;zh-CN&#39; &#125; &#125;&quot;16 class&#x3D;&quot;Header__Link&quot;17 active-class&#x3D;&quot;none&quot;18 exact19 &gt;20 zh&#123;&#123; $t(&#39;links.english&#39;) &#125;&#125;21 &lt;&#x2F;NuxtLink&gt;22 &lt;p&gt;&#123;&#123; $route.fullPath &#125;&#125;&lt;&#x2F;p&gt;23 &lt;&#x2F;el-container&gt;24&lt;&#x2F;template&gt;2526&lt;script&gt;27export default &#123;28 head() &#123;29 return &#123; title: this.$t(&#39;home.title&#39;) &#125;30 &#125;,31 components: &#123;&#125;,32 created() &#123;33 console.log(this)34 &#125;,35&#125;36&lt;&#x2F;script&gt;3738&lt;style scoped&gt;39.main &#123;40 margin: 30px auto;41&#125;42&lt;&#x2F;style&gt;43 创建page/index.vue 1&lt;script&gt;2import Index from &#39;@&#x2F;pages&#x2F;_lang&#x2F;index&#39;3export default Index4&lt;&#x2F;script&gt; 10、总结 到此 国际化就配置完成了。 运行结果 默认语言URL：http://localhost:3000 非默认语言URL：http://localhost:3000/en-US 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！ 程序的世界，写作的过程中部分文章难免会参考与借鉴网络上的一些资源、见解。如有侵权请与作者联系。如若如实侵权，文章会在24小时内删除。如若由于部分文章存在侵权行为给您带来不便还请见谅。 本博客仅仅为自己以及前端爱好者提供便利，不做任何商业用途。","tags":[{"name":"nuxt","slug":"nuxt","permalink":"http://www.blog.geyunjie.com/tags/nuxt/"},{"name":"i18n","slug":"i18n","permalink":"http://www.blog.geyunjie.com/tags/i18n/"}]},{"title":"vue 中时时监听网络的链接状态","date":"2020-07-03T08:53:03.000Z","path":"2020/07/03/vue-network-online/","text":"前言 ​ 由于本人的能力有限，如若有说得做的不对的地方，还望指出。当然，如若你有更好的方法，或者更优解，还望不吝赐教。 需求 ​ 实时监听app的联网状态，在断开网络的时候，提示用户网络断开了 自己的想法 ​ 监听用户的网络链接状态，如果断网，显示断网的页面。 实现在app.vue文件中添加一个属性来监控网络是否是开启状态 1data() &#123;2 return &#123;3 network: true, //默认有网4 &#125;;5 &#125;, 在app.vue 的mounted生命钩子函数里注册检测网络链接的状态 1mounted() &#123;2 // 检测断网3 window.addEventListener(\"offline\", () =&gt; &#123;4 console.log(\"已断网\");5 this.network = false;6 &#125;);7 window.addEventListener(\"online\", () =&gt; &#123;8 console.log(\"网络已连接\");9 this.network = true;10 &#125;);11&#125;, 在app.vue 的 判断network是否为false，如果是，跳转到断网的页面。为了简单，我就直接写在本页面上了 1&lt;div id=\"app\"&gt;2 &lt;div class=\"network\" v-if=\"!network\"&gt;3 网络已断开，链接网络，自动刷新4 &lt;/div&gt;5 &lt;div v-else&gt;6 &lt;keep-alive&gt;7 &lt;router-view :key=\"$route.path\" v-if=\"$route.meta.keepAlive\" /&gt;8 &lt;/keep-alive&gt;9 &lt;router-view :key=\"$route.path\" v-if=\"!$route.meta.keepAlive\" /&gt;10 &lt;/div&gt;11 &lt;/div&gt; 1.network &#123;2 width: 100vw;3 height: 100vh;4 line-height: 100vh;5 text-align: center;6&#125; 注意：部分文章可能会在不就的将来更新 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"vue","slug":"vue","permalink":"http://www.blog.geyunjie.com/tags/vue/"}]},{"title":"hexo从windows上移动的mac上的记录和遇到的坑","date":"2020-06-30T05:03:39.000Z","path":"2020/06/30/hexo-move-mac/","text":"前言 终于，迎来第一本苹果电脑，现在需要把很多东西移动到mac本上。下面是记录迁移博客的一些记录。 1.目前了解的是有两种方法进行迁移1.1 粘贴复制的方法 把所有的资源都粘贴到mac本上(安装的包除外) sudo yarn install / npm i 安装依赖 sudo npm i hexo-cli -g / sudo yarn add hero-cli -g 全局安装 hero-cli sudo hexo new xxx sudo hexo clean sudo hexo g sudo hexo d 1.2 在windows上把所有的资源上传到博客的一个新的分支上 在本地创建新的分支 把包以外的资源上传的此分支上 在mac上使用git clone 地址 把资源克隆到本地 然后再重复1.1上面的命令就ok了 2.遇到的坑 由于在装node.js的时候没有注意，把node装成了测试版本，由于版本太高，造成运行hexo的时候报错 一些变量找不到 解决办法：把node版本降级到稳定版本就好了。可以使用。 n 进行降级。 n是node的简写。 是管理node的版本的一个工具，详细用法可以自行百度 注意：部分文章可能会在不就的将来更新 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.blog.geyunjie.com/tags/hexo/"}]},{"title":"gitConfig","date":"2020-06-27T12:10:22.000Z","path":"2020/06/27/gitConfig/","text":"","tags":[]},{"title":"Homebrew","date":"2020-06-27T12:08:12.000Z","path":"2020/06/27/Homebrew/","text":"","tags":[]},{"title":"vue-proxy","date":"2020-05-12T13:43:10.000Z","path":"2020/05/12/vue-proxy/","text":"前端工程化开发时的跨域解决方案 此方案只能用于开发环境，线上最好设置同源策略 1. 场景前后端分离的项目 前后端不在同一服务器的情况下，前端要访问后端API，可通过在vue.config.js中配置代理服务器 2. 配置2.1 前提条件1：安装vue-lic 2：安装axios 用于发送请求 2.2 配置axios详细配置 请查看axios 2.3 开始发送请求此时控制台会报跨域错误 ， 这个时候 就需要设置跨域了，或者后台配置允许跨域（一般都不这么干） 2.4 前端配置跨域 先在根目录创建vue.config.js 写入以下代码 1 //vue-cli3.0 里面的 vue.config.js做配置2devServer: &#123;3 proxy: &#123;4 '/api': &#123; //这里最好有一个 /5 target: 'http://xx.xx.xx.xx:8080', // 后台接口域名6 ws: true, //如果要代理 websockets，配置这个参数7 secure: false, // 如果是https接口，需要配置这个参数8 changeOrigin: true, //是否跨域9 pathRewrite:&#123;10 '^/api':''11 &#125;12 &#125;13 &#125;14 &#125; axios 中配置的 根路径（baseURL）需要设置你要代理的路径 ，此时，就会把这个路径代理到后台接口的域名下 注意：部分文章可能会在不就的将来更新 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"proxy","slug":"proxy","permalink":"http://www.blog.geyunjie.com/tags/proxy/"}]},{"title":"vant-UI 组件的List渲染列表多页列表 切换不加载的问题","date":"2019-06-04T12:15:11.000Z","path":"2019/06/04/vant-list/","text":"1 数据渲染 template 1&lt;van-list2 v-for=\"items in tabbar\"3 :key=\"items.id\"4 v-show=\"items.isActive\"5 v-model=\"items.loading\"6 :finished=\"items.finished\"7 finished-text=\"没有更多了\"8 @load=\"onLoad(items)\"9 ref=\"listItem\"10&gt;11 &lt;van-cell v-for=\"item in items.list\" :key=\"item\" :title=\"item\"&gt;&#123;&#123;12 items.value13 &#125;&#125;&lt;/van-cell&gt;14&lt;/van-list&gt; data 1data() &#123;2 return &#123;3 tabbar: [4 &#123;5 id: 1,6 value: \"Lorem\",7 isActive: true,8 loading: false,9 finished: false,10 list: [],11 &#125;,12 &#123;13 id: 2,14 value: \"Lorem2\",15 isActive: false,16 loading: false,17 finished: false,18 list: [],19 &#125;,20 &#123;21 id: 3,22 value: \"Lorem3\",23 isActive: false,24 loading: false,25 finished: false,26 list: [],27 &#125;,28 ],29 &#125;;30 &#125;, methods 1onLoad(obj) &#123;2 // 异步更新数据3 // setTimeout 仅做示例，真实场景中一般为 ajax 请求4 setTimeout(() =&gt; &#123;5 for (let i = 0; i &lt; 10; i++) &#123;6 obj.list.push(obj.list.length + 1);7 &#125;89 console.log(obj.id);10 console.log(obj.finished);1112 // 加载状态结束13 obj.loading = false;1415 // 数据全部加载完成16 if (obj.list.length &gt;= 40) &#123;17 obj.finished = true;18 &#125;19 &#125;, 1000);20&#125;,21/**22 * 切换选项23 * obj 选项的数据24 */25onClickLoadData(obj) &#123;26 this.tabbar.forEach((item) =&gt; &#123;27 item.isActive = false;28 &#125;);29 obj.isActive = true;30&#125;, 切换页面 会发现 数据不会加载 这是为什么呢？ 这是因为页面渲染的时候 已经进行过加载了 在点击切换按钮的时候 并没有触发onload事件 那么你可能会说 那点击的时候调用一次onLoad事件不就好了么？ 对 点击的时候调用一次onLoad是会触发调用 但是呢？ 第一个问题：如果第一次加载的数据不足以铺满全屏，那么 数据就不会继续加载了 第二个问题：如果你的数据已经全部加载结束了，但是你点击切换的时候 由于你调用了onLoad事件。就还会触发。 那么！ 你也许会问 那该怎么做呢？ 那么现在我就告诉你 超简单 一行代码搞定 官方给了一个 check方法 所以 我们就可以这样做 1/**2 * 切换选项3 * obj 选项的数据4 */5onClickLoadData(obj) &#123;6 this.tabbar.forEach((item) =&gt; &#123;7 item.isActive = false;8 &#125;);9 obj.isActive = true;10+ this.$refs.listItem[obj.id - 1].check();检查点击的选项所显示的页面的滚动位置，若已滚动至底部，则会触发 load 事件 [obj.id - 1]为选中当前的list11&#125;, 完美搞定 注意：部分文章可能会在不就的将来更新 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"vant","slug":"vant","permalink":"http://www.blog.geyunjie.com/tags/vant/"}]},{"title":"vue-router","date":"2019-05-24T14:33:13.000Z","path":"2019/05/24/vue-router-parms/","text":"vue-router 路由传参方式 1 路由组件传参 1.1 布尔模式 1.1.1 配置路由 添加 props: true 选项 { // 我的地址列表 name: &quot;addressedit&quot;, path: &quot;/account/addressedit&quot;, props: true, component: () =&gt; import(&quot;@/views/addressEdit&quot;), },1.1.2 传递参数 在传参的过程中 写上 props: true, 说明开启了路由组件传参 onEditAddress(item, index) { this.$router.push({ name: &quot;addressedit&quot;, params: { id: index }, props: true, }); this.$toast(&quot;编辑地址:&quot; + index); },1.1.3 获取传递的参数 通过 route 对象上的 params 属性获取传递过来的属性 即：this.$route.params this.$route.params.id注意：部分文章可能会在不就的将来更新 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"vue-router","slug":"vue-router","permalink":"http://www.blog.geyunjie.com/tags/vue-router/"}]},{"title":"vue-i18n","date":"2019-05-18T12:25:10.000Z","path":"2019/05/18/vue-i18n/","text":"在vue项目中使用vue-i18n 实现国际化 在很多项目的开发中都需要设置国际化 我也是在最近的一个项目中使用到了国际化，所以总结一下 1. 安装vue-i18n1yarn add vue-i18n 2. 在根目录中创建lang文件夹 en_us.js 1export default &#123;2 footer: [\"home\", \"catgory\", \"cart\", \"account\", \"not login\"],3 header: &#123;&#125;,4 index: &#123;5 rowTime: &#123;6 title: \"xxx\",7 &#125;,8 recommend: \"xxx\",9 &#125;,10 userPageText: &#123;11 WishList: \"xxxx\",12 listText: &#123;13 MyOrders: \"xxx\",14 ...15 &#125;,16 LogOut: \"Log Out\",17 &#125;,18 login: &#123;19 btns: &#123;20 fackbook: \"xxx\",21 ...22 &#125;,23 placeholder: &#123;24 phone: \"xxx\",25 ...26 &#125;,27 &#125;,28&#125;; zh_cn.js 1export default &#123;2 footer: [\"首页\", \"分类\", \"购物车\", \"个人中心\", \"未登录\"],3 header: &#123;&#125;,4 index: &#123;5 rowTime: &#123;6 title: \"xxx\",7 &#125;,8 recommend: \"xxx\",9 &#125;,10 userPageText: &#123;11 Coupons: \"xxx\",12 listText: &#123;13 MyOrders: \"xxx\",14 ...15 &#125;,16 LogOut: \"退出\",17 &#125;,18 login: &#123;19 btns: &#123;20 fackbook: \"xxx \",21 ...22 &#125;,23 placeholder: &#123;24 phone: \"xxx\",25 ...26 &#125;,27 &#125;,28&#125;; index.js 1import Vue from \"vue\";2import VueI18n from \"vue-i18n\";3import &#123; Locale &#125; from \"vant\";4import enUS from \"vant/lib/locale/lang/en-US\";5import zhCN from \"vant/lib/locale/lang/zh-CN\";6import enLocale from \"./en_us\";7import zhLocale from \"./zh_cn\";89Vue.use(VueI18n);1011const messages = &#123;12 en: &#123;13 ...enUS,14 ...enLocale15 &#125;,16 zh: &#123;17 ...zhCN,18 ...zhLocale19 &#125;20&#125;;2122const i18n = new VueI18n(&#123;23 locale: \"zh\", // 设置默认语言24 messages: messages, // 设置资源文件对象25&#125;);2627// 更新vant组件库本身的语言变化，支持国际化28function vantLocales(lang) &#123;29 if (lang === \"en\") &#123;30 Locale.use(lang, enUS);31 &#125; else if (lang === \"zh\") &#123;32 Locale.use(lang, zhCN);33 &#125;34&#125;3536export &#123; i18n, vantLocales &#125;; main.js 1import &#123; i18n, vantLocales &#125; from \"./lang\";2vantLocales(i18n.locale);3new Vue(&#123;4 router,5 i18n,6 store,7 render: (h) =&gt; h(App),8&#125;).$mount(\"#app\"); 3. 使用 在需要使用到国际化的组件内直接使用 1&lt;van-cell2:title=\"$i18n.messages[this.$i18n.locale].userPageText.listText.MyOrders\"3class=\"iconfont icon-record\"4size=\"large\"5@click=\"$router.push(&#123; name: 'orderlist' &#125;)\"6/&gt; 为了方便 先引入 在使用 1created() &#123;2this.i18nMsg = this.$i18n.messages[this.$i18n.locale].userPageText;3&#125;, 1&lt;van-cell2:title=\"i18nMsg.listText.MyOrders\"3class=\"iconfont icon-record\"4size=\"large\"5@click=\"$router.push(&#123; name: 'orderlist' &#125;)\"6/&gt; 4. 按钮控制切换语言this.$i18n.locale,当你赋值为‘zh’时，导航栏就变成中文；当赋值为 ‘en’时，就变成英文 1&lt;div class=\"top_btn\" @click=\"changeLangEvent\"&gt;中文&lt;/div&gt; 1changeLangEvent() &#123;2console.log('changeLangEvent');3this.$confirm('确定切换语言吗?', '提示', &#123;4 confirmButtonText: '确定',5 cancelButtonText: '取消',6 type: 'warning'7&#125;).then(() =&gt; &#123;8 if ( this.$i18n.locale === 'zh' ) &#123;9 this.$i18n.locale = 'en';//关键语句10 console.log('en')11 &#125;else &#123;12 this.$i18n.locale = 'zh';//关键语句13 console.log('zh')14 &#125;15&#125;).catch(() =&gt; &#123;16 console.log('catch');17 this.$message(&#123;18 type: 'info',19 &#125;);20&#125;);21&#125; 这只是一个案例，可以用一个变量存储要改变 的语言，点击按钮的时候，访问设置属性，从而设置不同的语言 注意：部分文章可能会在不就的将来更新 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"i18n","slug":"i18n","permalink":"http://www.blog.geyunjie.com/tags/i18n/"}]},{"title":"Vue字体图标不显示的设置","date":"2019-03-20T16:00:00.000Z","path":"2019/03/21/iconfont/","text":"elementUI字体图标不显示 完美解决方案使用vue init webpack-simple xxx 创建的项目 在使用ElementUI的时候使用 字体图标时提示 根据报错提示可以看出时无法处理element-icons.ttf文件 原因时什么呢？ 相信大家都能够知道，这是因为webpack不知道怎么去处理.ttf的文件 这个时候我们就需要url-loader来帮助我们处理.ttf字体文件 1//这个时候需要我们去执行npm命令去下载url-loader2npm/cnpm install url-loader --save 下载完成后 去过你尝试去npm run dev 你会发现还是报和上面相同的错误，这是为什么呢？ 答案当然是因为你没有使用这个加载器（url-loader） 现在就需要你在webpack.config.js中去配置 这个配置说句实在的让小编好为难，因为一开始的时候咱也不知道该怎么配置啊，怎么办呢？ 这个时候度娘就显现出来了强大的威力，我开始了百度，看到别人的博客，知道了在rules下配置如下信息 1&#123;2 test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,3 loader: 'url-loader',4&#125; 别急着运行你的项目———这里有坑 看图 此图 是配置信息 此图是运行结果 此时你会发现 不报错了 但是我的图标去哪了？ 当时的小编也不知道啊 可能是被外星人给叼走了 哈哈 开个玩笑 经过小编的不懈努力 至于找到了问题的所在 这个因为没有设置limit选项 你可能会问这是什么东东 别急 先来和小编一起看看文档 看图可以看出 是要设置文件的大小的 这个属性的默认值是undefined 当然 小编怕你有疑问 再给你贴出一副图 这上面详细写了各个选项的具体功能 此时的你 应该已经很明确了问题原因的所在 和解决的办法 此时 就来看看我们伟大的成就吧 看图 配置 再来看运行的结果 如图： 此时，问题就完美解决了 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.blog.geyunjie.com/tags/javascript/"},{"name":"iconfont","slug":"iconfont","permalink":"http://www.blog.geyunjie.com/tags/iconfont/"},{"name":"vue","slug":"vue","permalink":"http://www.blog.geyunjie.com/tags/vue/"}]},{"title":"那些不常见，但却非常实用的 css 属性","date":"2018-09-16T13:33:07.000Z","path":"2018/09/16/css-attr-practical/","text":"前言 本文是本人在网络上看到的好的文章，好的 博客等等一切好的东西的地址。 如有侵犯作者权益的任何行为，请及时与本人沟通，本人将及时处理。 本人做这篇收集博客的主要初衷是为了自己和小伙伴能够更好的学习复习了解掌握更多的知识。 如有带来不便，请见谅！ 原文链接 如若想看原文。请点击 常见实用的css属性1、-webkit-line-clamp 作用： 可以把 块容器 中的内容限制为指定的行数。并且在超过行数后，在最后一行显示”…” 使用场景： 在文本内容多少不确定，但显示区域确定的时候，一般使用这个属性做限定 代码： 1display: -webkit-box; /*值必须为-webkit-box或者-webkit-inline-box*/2-webkit-box-orient: vertical; /*值必须为vertical*/3-webkit-line-clamp: 2; /*值为数字，表示一共显示几行*/4overflow: hidden; /*超出隐藏。必须设置*/ 查看MDN 请点击 2、all 作用：将除却 unicode-bidi 与 direction 之外的所有属性重设至其初始值，或继承值。 使用场景： 偶尔看到， 未使用过， 具体不太清楚， 可查看mdn，有例子 代码： 1all: unset; /*initial | inherit | unset*/ initial 改变该元素或其父元素的所有属性至初始值。 inherit 改变该元素或其父元素的所有属性的值至他们的父元素属性的值 unset 如果该元素的属性的值是可继承的，则改变该元素或该元素的父元素的所有属性的值为他们父元素的属性值，反之则改变为初始值 查看MDN 请单击 3、box-decoration-break 作用：用来定义当元素跨多行、多列或多页时，元素的片段应如何呈现。 指定的值将影响以下元素的表现： background border border-image box-shadow clip-path margin padding 使用场景： 代码： 1/* Keyword values */2box-decoration-break: slice;3box-decoration-break: clone;45/* Global values */6box-decoration-break: initial;7box-decoration-break: inherit;8box-decoration-break: unset; 查看MDN 请点击 4、caret-color 作用：用来定义插入光标（caret）的颜色，这里说的插入光标，就是那个在网页的可编辑器区域内，用来指示用户的输入具体会插入到哪里的那个一闪一闪的形似竖杠 | 的东西。 使用场景：改变可编辑区域的插入光标的颜色 代码： 1caret-color: red; 查看MDN 请点击 5、clip-path / shape-outside clip-path 作用：使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。类似的裁剪还有 svg 的 clipPath。 取值：clip-path 的取值有以下几种图形 inset(xxx): 裁剪为长方形 circle(xx): 裁剪为原型 ellipse(xxx): 裁剪为椭圆 polygon(xx): 裁剪为多边形 none: 不裁剪 使用场景：对元素进行裁剪时 代码： 1/* Keyword values */2clip-path: none;34/* &lt;clip-source&gt; values */ 5clip-path: url(resources.svg#c1);67/* &lt;geometry-box&gt; values */8clip-path: margin-box;9clip-path: border-box;10clip-path: padding-box;11clip-path: content-box;12clip-path: fill-box;13clip-path: stroke-box;14clip-path: view-box;1516/* &lt;basic-shape&gt; values */17clip-path: inset(100px 50px);18clip-path: circle(50px at 0 100px);19clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);20clip-path: path('M0.5,1 C0.5,1,0,0.7,0,0.3 A0.25,0.25,1,1,1,0.5,0.3 A0.25,0.25,1,1,1,1,0.3 C1,0.7,0.5,1,0.5,1 Z');2122/* Box and shape values combined */23clip-path: padding-box circle(50px at 0 100px);2425/* Global values */26clip-path: inherit;27clip-path: initial;28clip-path: unset; 查看MDN 请点击 shape-outside 定义：定义了一个可以是非矩形的形状，相邻的内联内容应围绕该形状进行包装。 默认情况下，内联内容包围其边距框; shape-outside提供了一种自定义此包装的方法，可以将文本包装在复杂对象周围而不是简单的框中。 作用：属性指定使用下面列表的值来定义浮动元素的浮动区域。这个浮动区域决定了行内内容（浮动元素）所包裹的形状。 取值：详细请查看MDN 语法： 1/* 关键字值 */2shape-outside: none;3shape-outside: margin-box;4shape-outside: content-box;5shape-outside: border-box;6shape-outside: padding-box;78/* 函数值 */9shape-outside: circle();10shape-outside: ellipse();11shape-outside: inset(10px 10px 10px 10px);12shape-outside: polygon(10px 10px, 20px 20px, 30px 30px);1314/* &lt;url&gt; 值 */15shape-outside: url(image.png);1617/* 渐变值 */18shape-outside: linear-gradient(45deg, rgba(255, 255, 255, 0) 150px, red 150px);1920/* 全局值 */21shape-outside: initial;22shape-outside: inherit;23shape-outside: unset; 6、object-fit / object-position object-fit 作用： 指定可替换元素的内容应该如何适应到其使用的高度和宽度确定的框 可以通过使用 object-position 属性来切换被替换元素的内容对象在元素框内的对齐方式。 取值： contain：被替换的内容将被缩放，以在填充元素的内容框时保持其宽高比。 整个对象在填充盒子的同时保留其长宽比，因此如果宽高比与框的宽高比不匹配，该对象将被添加“黑边”。 cover：被替换的内容在保持其宽高比的同时填充元素的整个内容框。如果对象的宽高比与内容框不相匹配，该对象将被剪裁以适应内容框 fill：被替换的内容正好填充元素的内容框。整个对象将完全填充此框。如果对象的宽高比与内容框不相匹配，那么该对象将被拉伸以适应内容框 none：被替换的内容将保持其原有的尺寸。 scale-down：内容的尺寸与 none 或 contain 中的一个相同，取决于它们两个之间谁得到的对象尺寸会更小一些。 案例详情 请查看MDN object-position 作用：规定了可替换元素的内容，在这里我们称其为对象（即 object-position 中的 object），在其内容框中的位置。可替换元素的内容框中未被对象所覆盖的部分，则会显示该元素的背景 语法： 1/* &lt;position&gt; values */2object-position: center top;3object-position: 100px 50px;45/* Global values */6object-position: inherit;7object-position: initial;8object-position: unset; 取值： position:使用 1 到 4 个值来定义该元素在它所处的二维平面中的定位。可以使用相对或绝对偏移 详情请点击MDN 7、font-stretch 作用：为字体定义一个正常或经过伸缩变形的字体外观，它仅仅意味着当有多种字体可供选择时，会为字体选择最适合的大小。 语法： 1/* Keyword values */2font-stretch: ultra-condensed;3font-stretch: extra-condensed;4font-stretch: condensed;5font-stretch: semi-condensed;6font-stretch: normal;7font-stretch: semi-expanded;8font-stretch: expanded;9font-stretch: extra-expanded;10font-stretch: ultra-expanded;1112/* Global values */13font-stretch: inherit;14font-stretch: initial;15font-stretch: unset; 查看详情请点击MDN 8、max-content / min-content / fill-available / fit-content 这几个值都可用在 width, height, min-width, min-height, max-width 和 max-height 属性上。 display 必须为 inline-block 或者 block，否则上面的值不起作用。 fill-available 元素撑满可用空间。参考的基准为父元素有多宽多高。 类似子元素的 div 撑满父元素的宽，fill-available 不仅可以撑满宽还能撑满高 max-content它的宽度或者高度，会自动调整为，刚刚好容纳下子元素中那个长度最长(按照文字不换行时计算)的元素即可。参考的基准为子元素有多宽多高。 min-content它的宽度或者高度，会自动调整为，刚刚好容纳下子元素中那个“最小宽度值”最大的元素即可，剩余超长的要么换行，要么溢出参考的基准为子元素“最小宽度值”有多宽多高。 什么是“最小宽度值”？比如图片，最小宽度值，就是图片原始的宽高；如果是一串中文，则最小宽度值为单个汉字的宽高；如果是一串英文，则最小宽度值为里面单词最长的那个。 fit-content表示元素自动伸缩到内容的宽度，和 max-content 的区别为，都是刚刚好容纳下子元素中那个长度最长的元素即可。 不同的是 max-content 在计算时按照文字不换行时计算，如果超过父元素，则不换行，直接产生滚动条；而 fit-content 在超过父元素后，换行，不产生滚动条。 9、fit-content()函数 使用场景：用在 grid 布局当中。 10、resize11、scroll-behavior 作用：当用户通过 API 触发滚动操作时，CSS 属性 scroll-behavior 为一个滚动框指定滚动行为， 平滑到达还是立即到达 12、max() / min() max 在两者这件取最大；min 函数在两者之间取最小。 max，min 可以用在任何可以设置 , , , , , , or 等值的地方 13、clamp() 作用：clamp 函数会在定义的 三个值之间，取中间的那个值，是大小在中间，不是位置在中间， 语法：clamp(MIN, VAL, MAX) 使用场景：和 max，min 函数一样，可以用在任何可以设置 , , , , , , or 等值的地方 14、conic-gradient() 作用：”锥形渐变”。它是围绕中心点按照扇形方向进行旋转的渐变(而不是从中心点辐射) 15、:out-of-range / :in-range16、writing-mode 作用：定义了文本水平或垂直排布以及在块级元素中文本的书写方向 17、inline-size18、block-size如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！ 程序的世界，写作的过程中部分文章难免会参考与借鉴网络上的一些资源、见解。如有侵权请与作者联系。如若如实侵权，文章会在24小时内删除。如若由于部分文章存在侵权行为给您带来不便还请见谅。 本博客仅仅为自己以及前端爱好者提供便利，不做任何商业用途。","tags":[{"name":"css","slug":"css","permalink":"http://www.blog.geyunjie.com/tags/css/"}]},{"title":"好的文章 好的博客  好的语录等等","date":"2018-09-12T13:33:07.000Z","path":"2018/09/12/classic-article/","text":"前言 本文是本人在网络上看到的好的文章，好的 博客等等一切好的东西的地址。 如有侵犯作者权益的任何行为，请及时与本人沟通，本人将及时处理。 本人做这篇收集博客的主要初衷是为了自己和小伙伴能够更好的学习复习了解掌握更多的知识。 如有带来不便，请见谅！ html篇css篇js篇nodejs篇vue篇1.vue.js 组件复用和扩展之道2.你可能不知道的一些Vue实战技巧代码整洁之道1.编写自文档化JavaScript的15种方法MAC 篇1、Mac 键盘快捷键性能优化1.第51期 网易云音乐前端性能监控实践 &amp; 那些不常见却非常实用的css属性 &amp; 携程RN渲染性能优化实践 注意：部分文章可能会在不就的将来更新 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"css","slug":"css","permalink":"http://www.blog.geyunjie.com/tags/css/"}]},{"title":"css 中间文字 两端横线","date":"2018-09-12T13:33:07.000Z","path":"2018/09/12/css-line-text/","text":"前言 本人水平有限，文章内容难免会出现问题，如果有问题欢迎指出，谢谢 方式一 为元素加定位的方式 dome链接地址 http://www.example.geyunjie.com/css/line html 代码 1&lt;body&gt;2 &lt;div class=\"dome1\"&gt;测试一下&lt;/div&gt;3&lt;/body&gt; css 代码 1&lt;style&gt;23 .dome1&#123;4 text-align: center;5 position: relative;6 &#125;7 .dome1::after&#123;8 position: absolute;9 content: \"\";10 display: block;11 width: 40%;12 height: 0;13 border: 1px solid #eee;14 top: 50%;15 left: 0;16 &#125;17 .dome1::before&#123;18 position: absolute;19 content: \"\";20 display: block;21 width: 40%;22 height: 0;23 border: 1px solid #eee;24 top: 50%;25 right: 0;26 &#125;2728&lt;/style&gt; 注意：部分文章可能会在不就的将来更新 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"css","slug":"css","permalink":"http://www.blog.geyunjie.com/tags/css/"}]},{"title":"CommonJS, AMD, CMD的区别","date":"2018-08-15T10:54:07.000Z","path":"2018/08/15/amdcmdcom/","text":"CommonJS, AMD, CMD都是JS模块化的规范。CommonJS是服务器端js模块化的规范，NodeJS是这种规范的实现。AMD(异步模块定义)和CMD(通用模块定义)都是浏览器端js模块化的规范。RequireJS 遵循的是 AMD，SeaJS 遵循的是 CMD CommonJS（同步模块定义）一个单独的文件就是一个模块加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象所以，定义一个模块就是写一个新的js文件，但是最后要将文件的内容exports出来 如何定义模块和加载模块？ 1//定义一个module.js文件2var A = function() &#123;3 console.log('我是定义的模块');4&#125;5/* 6 * 导出这个模块7 * 1.第一种返回方式 module.exports = A; 8 * 2.第二种返回方式 module.exports.test = A9 * 3.第三种返回方式 exports.test = A;10 * 注意：module.exports导出方式 与 exports导出方式是有区别的11 * 具体区别详见其他文章12 */13exports.test = A;1415//再写一个dome.js文件，导入刚才定义好的模块16const module = require(\"./module\"); //加载这个模块 require中是导入模块的路径 前面的变量名自定义 代表的是导入模块所导出的对象1718/* 调用这个模块，不同的返回方式用不同的方式调用19 * 1.第一种调用方式 module();20 * 2.第二种调用方式 module.test();21 */22module.test();232425/* 26 * 接下来我们去执行这个文件，前提是你本地要安装node.js27 * 首先打开cmd, cd到这个文件所在的目录下,执行: node dome.js28 */29node dome.js30//输出结果：我是定义的模块 以上就是CommonJS规范下的模块定义与加载的形式 注意： CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作 ​ 因此 -&gt; 像Node.js比较适用CommonJS的原因在于：Node.js主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式 ​ 而 -&gt; 浏览器环境 则 不适合适用CommonJS，原因在于浏览器环境要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD CMD 解决方案 AMD（异步模块定义）**AMD规范通过define方法去定义模块，通过require方法去加载模块。RequireJS实现了这种规范 AMD只有一个接口：define(id?,dependencies?,factory); 它要在声明模块的时候制定所有的依赖(dep)，并且还要当做形参传到factory中。要是没什么依赖，就定义简单的模块（或者叫独立的模块 1//编写一个module1.js文件2//定义独立的模块3define(&#123;4 methodA: function() &#123;5 console.log('我是module1的methodA'); 6 &#125;,7 methodB: function() &#123;8 console.log('我是module1的methodB'); 9 &#125;10&#125;);1112//编写一个module2.js文件13//另一种定义独立模块的方式14define(function () &#123;15 return &#123;16 methodA: function() &#123;17 console.log('我是module2的methodA'); 18 &#125;,19 methodB: function() &#123;20 console.log('我是module2的methodB'); 21 &#125;22 &#125;;23&#125;);2425//编写一个module3.js文件26//定义非独立的模块（这个模块依赖其他模块）27define(['module1', 'module2'], function(m1, m2) &#123;28 return &#123;29 methodC: function() &#123;30 m1.methodA();31 m2.methodB();32 &#125;33 &#125;;3435&#125;);3637//再定义一个main.js，去加载这些个模块38require(['module3'], function(m3)&#123;39 m3.methodC();40&#125;);4142//我们在一个html文件中去通过RequireJS加载这个main.js43//等号右边的main指的main.js44&lt;script data-main=\"main\" src=\"require.js\"&gt;&lt;/script&gt;4546//浏览器控制台输出结果47我是module1的methodA48我是module2的methodB CMD（通用模块定义）CMD是SeaJS 在推广过程中对模块定义的规范化产出 AMD和CMD的区别： 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible（尽可能的懒加载，也称为延迟加载，即在需要的时候才加载）。 CMD 推崇依赖就近，AMD 推崇依赖前置。虽然 AMD 也支持 CMD 的写法，同时还支持将 require 作为依赖项传递，但 RequireJS 的作者默认是最喜欢上面的写法，也是官方文档里默认的模块定义写法。 AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。 注意：部分文章可能会在不就的将来更新 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"common.js","slug":"common-js","permalink":"http://www.blog.geyunjie.com/tags/common-js/"},{"name":"cmd","slug":"cmd","permalink":"http://www.blog.geyunjie.com/tags/cmd/"},{"name":"amd","slug":"amd","permalink":"http://www.blog.geyunjie.com/tags/amd/"}]},{"title":"vue基础 一 之 指令","date":"2018-08-15T10:54:07.000Z","path":"2018/08/15/vue-1/","text":"vue基础指令以及案例v-html与v-text v-html 可以渲染标签 但存在隐患 在敏感的地方使用可能会造成 跨站脚本攻击 v-text 会直接把标签当成文本渲染 v-cloak v-cloak 的作用是阻止页面在mounted之前渲染标签内的数据 也就是说在插值表达式没有被替换之前，不渲染页面 v-bind 与 v-on v-bind 绑定属性 缩写为 ： v-on 绑定事件 缩写为 @ 跑马灯例子 事件修饰符 .stop 阻止事件冒泡 .prevent 阻止默认事件（阻止默认行为） .capture 实现捕获触发事件 .self 只有点击自己的时候才会触发 .once 只触发一次 .stop 和 .self 的区别 相同点：都能阻止冒泡 不同点：stop阻止所有的事件冒泡 self只阻止了自己的事件冒泡（其他组件还是会冒泡） v-model实现表单元素 和model 中的数据双向绑定 只能使用在 表单元素中 是v-on 和 v-bind 在表单上同时使用时的 语法糖 简易计算器 样式绑定使用class绑定样式 数组：这是一个可爱的h1 数组中使用三元表达式：这是一个可爱的h1 数组中嵌套对象：这是一个可爱的h1 直接使用对象：这是一个可爱的h1 使用style 内联样式 对象：这是一个可爱的h1 定义到data中 直接 :style 引用 以数组的形式 引用多个 data 字段 v-for 与 ：key用于编辑数组或对象 数组：这是一个可爱的h1 对象：这是一个可爱的h1 对象数组：这是一个可爱的h1 遍历数字：。。。 vue2.0之后，必须给每一项绑定一个key key绑定的值只能是数字或字符串（string、number） key的作用是给每一项一个唯一的标识，能够节省性能 v-if 和v-show 控制元素的显示或隐藏 v-if：控制元素时候渲染dom节点 每次都会创建或者删除dom节点 有较高的切换性能消耗 v-show：控制元素的dispaly：none； 使元素显示或隐藏 有较高的初始渲染消耗","tags":[{"name":"vue","slug":"vue","permalink":"http://www.blog.geyunjie.com/tags/vue/"}]},{"title":"布局","date":"2018-07-12T16:00:00.000Z","path":"2018/07/13/layout/","text":"布局，是每个前端工程师的基本功。结合自己的学习，总结一下自己所了解的一些比较重要的关于布局的一些知识 比如：两栏布局，三栏布局（统称为多栏布局），等高布局等等 两栏布局定宽做法css代码 1.container&#123;2 background-color: #008c8c;3&#125;4.aside&#123;5 float: left;6 background-color: brown;7 width: 300px;8&#125;9.main&#123;10 float: right;11 background-color: blueviolet;12 width: 1000px;13&#125;14.clearfix::after&#123;15 content: '';16 display: block;17 clear: both;18&#125; html代码 1&lt;div class=\"container clearfix\"&gt;2 &lt;aside class=\"aside\"&gt;lorem*10&lt;/aside&gt;3 &lt;div class=\"main\"&gt;Lorem*10&lt;/div&gt;4&lt;/div&gt; 效果图 注意： html中的 lorem*10是乱数假文，是代替文字的。偷懒使用一下 ，在你需要使用的时候，在编辑器中输入lorem*10就会出现图片上的那些英文 现在实现的两栏布局是定宽的。但是，很多时候的业务需求可能是主体区域是不定宽的 不定宽做法只需要把主体区域的定宽的属性删除，把浮动属性删除，添加上overflow: hidden属性即可 css代码 1.container&#123;2 background-color: #008c8c;3&#125;4.aside&#123;5 float: left;6 background-color: brown;7 width: 300px;8&#125;9.main&#123;10 -float: right;11 background-color: blueviolet;12 -width: 1000px;13 +overflow: hidden;14&#125;15.clearfix::after&#123;16 content: '';17 display: block;18 clear: both;19&#125; 减号代表删除的代码，加号代表添加的代码 html代码不变 效果图不再展示，因为展示的话需要gif动态图，制作太繁琐。如需看效果，只需要把代码粘过去运行即可 注意：要想知道为什么加了overflow: hidden属性后可以实现这种效果，请详细了解块级格式化上下文（简称：BFC），其他文章有详细介绍。html部分，需要（必须）把浮动元素放在前面 可能你会遇到这种问题：两个区域距离太近，想让中间有缝隙，这该怎么做呢？ 答： 设置浮动元素的外边距即可，那边需要缝隙，就写那边的外边距。 如果你设置的不是浮动元素，还要与浮动之间有距离，那你就必须设置你想要的距离加上浮动元素的宽度 三栏布局三栏布局的原理：三栏布局以及多栏布局的思想和两栏布局相同。 css代码 1.container&#123;2 background-color: #008c8c;3&#125;4.left&#123;5 float: left;6 background-color: brown;7 width: 300px;8 margin-right: 20px;9&#125;10.main&#123;11 background-color: blueviolet;12 overflow: hidden;13&#125;14.right&#123;15 float: right;16 width: 300px;17 background-color: yellow;18 margin-left: 20px;19&#125;20.clearfix::after&#123;21 content: '';22 display: block;23 clear: both;24&#125; html代码 1&lt;div class=\"container clearfix\"&gt;2 &lt;aside class=\"left\"&gt;Lorem&lt;/aside&gt;3 &lt;aside class=\"right\"&gt;Lorem&lt;/aside&gt;4 &lt;div class=\"main\"&gt;Lorem&lt;/div&gt;5&lt;/div&gt; 效果图： 注意：上面代码为自适应的布局 等高布局方式一 ： CSS3的弹性盒模型方式二 ： javascript控制方式三 ： 伪等高核心思路： 给非主体盒子设置一个主体盒子永远都不可能超出的高度 给非主体盒子设置一个下外边距为 高度 减去 需要显示的非主体盒子的其他盒子的最大高度 的负边距。例如下面代码：margin-bottom: -（10000-710）px。此时，清除浮动的伪元素必定会在次处或以下 给总体大盒子设置为overflow: hidden，让超出的隐藏。 这样，当主体内容足够多时，其他区域就会以背景图的方式显示 缺点：必须要精确的得知侧边栏的高度，以防止主体区域内容过少，使其他的盒子显示不全 css代码 1.container&#123;2 background-color: #008c8c;3 overflow: hidden;//+4&#125;5.left&#123;6 float: left;7 background-color: brown;8 width: 300px;9 margin-right: 20px;10 height: 10000px;//+11 margin-bottom: -9290px;//+12&#125;13.main&#123;14 background-color: blueviolet;15 overflow: hidden;16&#125;17.clearfix::after&#123;18 content: '';19 display: block;20 clear: both;21&#125; html代码与两栏布局相同 演示就不再次演示了 大家可以实操练习下 多栏布局都可以使用这种思想做 注意：这种方式实现的并不是真正的等高，而是伪等高，就是看着是等高，其实不是 html元素的书写顺序必须先写浮动元素，然后再写自适应元素 原因：如果先写自适应元素，自适应元素是常规流盒子，默认是撑满屏幕的。然后，下面再使用浮动元素的时候，浮动元素会避开标准流盒子。就会导致，自适应的盒子再顶部，浮动的元素在下面 27分","tags":[{"name":"html，css","slug":"html，css","permalink":"http://www.blog.geyunjie.com/tags/html%EF%BC%8Ccss/"}]},{"title":"获取url的各个参数的值","date":"2018-05-12T03:33:07.000Z","path":"2018/05/12/qureyUrlParams/","text":"思路由于下面的代码用的是简写的方式 为了所有人都能看得懂 或者说即使看不懂 看到思路 根据思路也能实现、所以写了以下的个人思路 有不好的 请私信我 对于私信的人 感激不尽 因为的你私信会让小编更上一层楼 定义一个url地址（就是确定要 解析的url地址） 定义一个方法用来解析参数 方法：先创建一个对象，用于存放参数的键值对 方法：先判断传入的参数是否为空 为空 直接返回一个空对象，不为空 进行解析 方法：使用split方法把 ？ 符号之前的数据剔除 方法：使用split方法把数据以 &amp; 作为切割点 切割成数组 方法：使用forEach对切割好的数组进行遍历 方法：再次使用split方法 把遍历的每一项 以 = 进行分割 分割成的数组的第一项作为 key 属性 第二项作为 value 属性 存放到之前定义好的 空对象中 方法：返回这个对象 具体实现代码1// 定义一个需要传递的URL2 const url = 'https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;tn=baidu'3 /*4 * str =&gt;需要解析的url5 * 返回的是一个解析好的对象6 * &#123;7 f: \"8\"8 ie: \"utf-8\"9 rsv_bp: \"1\"10 tn: \"baidu\"11 &#125;12 */13 const qureyUrlParams = function (str) &#123;14 const objStr = &#123;&#125;15 str &amp;&amp; str.split('?')[1].split('&amp;').forEach(item =&gt; objStr[item.split('=')[0]] = item.split('=')[1]);16 return objStr17 &#125;18 console.log(qureyUrlParams(url)); 相信 以上面写的思路，大家都能看的非常明白 但是：小编觉得这不是最好的解决方案，最好的解决方案是用正则表达式来进行解析。 正则表达式 的解决方案 详见 小编的 正则表达式 里面的案例 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.blog.geyunjie.com/tags/javascript/"}]},{"title":"微信小程序登录验证","date":"2018-04-15T00:54:07.000Z","path":"2018/04/15/login-wx/","text":"流程图在说怎么做之前，先看下这个流程图 思路看完这个流程图 ，相必大家已经很清楚了。 为了防止大家不太明白，再次给大家聊一下流程图 在授权之前，应该选判断是否已经授权。因为在别的地方已经授权了 已授权：直接跳过授权的过程，进行本该进行的操作 未授权：进如以下流程进行授权 获取用户信息。 由于用户信息是隐私为题，需要征求用户的同意。所以，把这一步放到第二步，而不是第三步。 用户同意获取用户信息：获取用户系信息 用户不同意获取用户信息：终止以下操作，返回最开始授权之前的页面 使用微信提供的API接口wx.login()，请求微信的服务器，获取code 成功：返回code 失败：返回错误信息 使用获取到的用户信息+code向公司的服务器发起获取Token的 接口 请求。服务器根据传递的数据进行判断 请求成功：返回token 和请求成功的 状态信息等 请求失败：返回失败的 错误信息 比如：code不一致等（后端程序员编写具体的接口返回内容） 当请求成功后，进行本地存储 ，并开始授权之前的操作 使用微信小程序提供的API接口，进行本地存储 以后再有地方需要token的地方，就会直接从本地获取Token，而无需再次进行用户授权 注意：部分文章可能会在不就的将来更新 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"小程序","slug":"小程序","permalink":"http://www.blog.geyunjie.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"前端规范","date":"2018-04-15T00:54:07.000Z","path":"2018/04/15/norm/","text":"前端规范 命名规则 头 : header 内容 : content/container 尾部 : footer 导航 : nav 侧栏 : sidebar 栏目 : column 外围盒子控制整体布局 : wrapper 左 右 中 : left / center / right 登录条 : loginbar 标志 : logo 广告 : banner 页面主题 : main 热点 : hot 新闻 : news 下载 : download 子导航 : subnav 菜单 : menu 子菜单 : submenu 搜索 : search 友情链接 : friendlink 页脚 : footer 版权 : copyright 滚动 : scroll 内容 : content 标签页 : tab 文章列表 : list 提示信息 : msg 小技巧 : tips 栏目标题 : title 加入 : joinus 指南 : guild 服务 : service 注册 : regsiter 状态 : status 投票 : vote 合作伙伴 : partner 注释的写法 1/*Footer Start*/2内容区3/*Footer End*/ id的命名 3.1 页面结果 容器 : container 页头 : header 内容 : content / container 页面主体 : main 页尾 : footer 导航 : nav 侧栏 : sidebar 栏目 : column 页面外围控制整体布局宽度 : wrapper 左右中 : left / right / center 3.2 导航 导航 : nav 主导航 : mainbav 子导航 : subnav 顶导航 : topnav 边导航 : sidebar 左导航 : leftsidebar 右导航 : rightsidebar 菜单 : menu 子菜单 : submenu 标题 : title 摘要 : summary 3.3 功能 标志 : logo 广告 : banner 登陆 : login 登录条 : loginbar 注册 : regsiter 搜索 : search 功能区 : shop 标题 : title 加入 : joinus 状态 : status 按钮 : btn 滚动 : scroll 标签页 : tab 文章列表 : list 提示信息 : msg 当前的 : current 小技巧 : tips 图标 : icon 注释 : note 指南 : guild 服务 : service 热点 : hot 新闻 : news 下载 : download 投票 : vote 合作伙伴 : partner 友情链接 : link 版权 : copyright css样式 4.1 重置默认样式 4.2 添加自定义全局样式 4.3 抽取文件定义单页面全局样式 4.3 样式定义规则 ： 重定义 &gt; 伪类 &gt; 自定义 （便于阅读） javascript 书写规范 5.1 书写过程 ：每行代码结束结构统一（有无分号-&gt;有的话，每行代码都应该有-&gt; eslint 设置规则，遵守即可）。防止代码冗余 | 与不小心造成与远程代码造成冲突 5.2 库的引入 ：根据项目需求，尽量的少引入。引入的时候，尽量使用按需引入，节省资源 5.3 变量命名规则 ：驼峰式命名法 5.4 类命名 : 首字母大写, 驼峰式命名 5.5 函数命名: 首字母小写驼峰式命名 5.6 命名语义化, 尽可能利用英文单词或其缩写 5.7 尽量避免使用存在兼容性及消耗资源的方法或属性, 比如eval() &amp;; innerText 5.8 后期优化中, JavaScript非注释类中文字符须转换成unicode编码使用, 以避免编码错误时乱码显示; 5.9 代码结构明了, 加适量注释. 提高函数重用率 5.10 注重 样式 结构 行为 相分离 图片规范 6.1 所有页面元素类图片均放入img文件夹 6.2 图片格式仅限于gif || png || jpg 6.3 命名全部用小写英文字母 || 数字 || _ 的组合,其中不得包含汉字 || 空格 || 特殊字符;尽量用易懂的词汇, 便于团队其他成员理解; 另, 命名分头尾两部分, 用下划线隔开, 比如ad_left01.gif || btn_submit.gif 6.4 在保证视觉效果的情况下选择最小的图片格式与图片质量, 以减少加载时间 6.5 尽量避免使用半透明的png图片(若使用, 请参考css规范相关说明) 6.6 运用css sprite技术集中小的背景图或图标, 减小页面http请求, 但注意, 请务必在对应的sprite psd源图中划参考线, 并保存至img目录下 注释规范 7.1 html注释: 注释格式&lt; !–这儿是注释–&gt;, ‘–’只能在注释的始末位置,不可置入注释文字区域 7.2 css注释: 注释格式 /*这儿是注释*/ 7.3 JavaScript注释, 单行注释使用’//这儿是单行注释’ ,多行注释使用 /* 这儿有多行注释 */ 结束语 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.blog.geyunjie.com/tags/javascript/"}]},{"title":"js获取html到fontSize大小","date":"2018-03-20T16:00:00.000Z","path":"2018/03/21/js-set-html-font-size/","text":"前言 ​ 由于本人的能力有限，如若有说得做的不对的地方，还望指出。当然，如若你有更好的方法，或者更优解，还望不吝赐教。 获取视窗高度1let htmlWidthPX = document.documentElement.clientWidth || document.body.clientWidth 获取html的font-size1let htmlFontSizePX=document.getElementsByTagName('html')[0].style.fontSize 设置fontSize1document.getElementsByTagName('html')[0].style.fontSize= xxx + \"px\" 更新 1.window.getComputedStyle(element, [pseudoElt]) 获取指定元素对应CSS属性的最终计算值 官方解释 参数解析 element：必需，要获取样式值的元素对象 pseudoElt：可选，表示指定节点的伪元素（:before、:after、:first-line、:first-letter等） 兼容性 IE9+浏览器支持此方法 edge浏览器支持此方法 谷歌浏览器支持此方法 opera浏览器支持此方法 火狐浏览器支持此方法 safria浏览器支持此方法 例子 window.getComputedStyle(element,null) &lt;!--￼3--&gt; 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！ 程序的世界，写作的过程中部分文章难免会参考与借鉴网络上的一些资源、见解。如有侵权请与作者联系。如若如实侵权，文章会在24小时内删除。如若由于部分文章存在侵权行为给您带来不便还请见谅。 本博客仅仅为自己以及前端爱好者提供便利，不做任何商业用途。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.blog.geyunjie.com/tags/javascript/"}]},{"title":"JavaScript正则表达式","date":"2018-02-15T12:33:07.000Z","path":"2018/02/15/RegExp/","text":"写在前面正则表达式是一种字符串规则，在很多处理字符串的场合能够发挥出不可估量的强大，比如表单验证，数据替换等等。作为一名程序员，不管是前端还是后端，都应该掌握这门技术。此文章是本人在学习正则表达式时的一些笔记，以及封装的一些比较常用且功能强大的函数。希望这篇文章能够帮助到其他的小伙伴。当然，可能有些封装的不尽完美，所以，不尽完美之处，还请请私信我。我们共同进步。 正则表达式 (基础部分) regular expression : RegExp 正则表达式 作用： 用来处理字符串的规则 只能处理字符串、 他是一个规则 可以验证字符串是否符合某个规则(test方法)，也可以把字符串中符合规则的内容捕获到(exec/match方法) 编写正则表达式 创建方式有两种 1//字面量的方式创建 (两个//之间包起来的都是用来描述正则规则的元字符)2let reg=/\\d+/;34//实例的方式 构造函数创建 两个参数： 一个是元字符字符串 修饰符字符串5let reg1=new RegExp('\\\\d+'); 正则表达式由两部分组成 元字符 修饰符 1/* 1. 常用的元字符*/23// ==&gt; 1.量词元字符 设置出现的次数4 // 1. * 0到多次5 // 2. + 1到多次6 // 3. ？ 0次 || 一次7 // 4. &#123;n&#125; 出现n次 n为大于0的正整数8 // 5. &#123;n,m&#125; 出现 n 到 m 次910/* 2.特殊元字符 ： 单个或者组合在一起代表特殊的含义*/11// 1. \\ 转义字符（普通字符-&gt;特殊-&gt;普通）12// 2. . 除\\n（换行符）以外的任意字符13// 3. ^ 以哪一个元字符作为开始（^看瑞特符号）14// 4. $ 以哪一个元字符作为结束15// 5. \\n 换行符16// 6. \\d 0~9之间的一个数字17// 7. \\D 非0~9之间的一个数字18// 8. \\w 数字、字母、下划线 中的任意一个字符19// 9. \\s 一个空白字符 （包含空格 制表符 换页符等）20// 10.\\t 一个制表符 （一个TAB键：4个空格）21// 11.\\b 匹配一个单词的边界22// 12.x|y x或者y中的一个字符23// 13.[xyz] x或者y或者z中的一个字符24// 14.[^xy] 除了x、y以外的字符25// 15.[a-z] 指定a到z这个范围中的任意字符 [0-9a-zA-Z_] === \\w26// 16.[^a-z] 15/条的取反27// 17.() 正则中的分组28// 18.(?:) 只匹配不捕获29// 19.(?=) 正向预查30// 20.(?!) 负向预查3132/* 3.普通元字符 ： 代表本身含义的 */33// /zhnegze/ 此正则匹配的就是 'zhengze' 修饰符 1/* 正则表达式常用的修饰符：i m g */2// 1. i ignoreCase (一个闹尅死) 忽略单词大小写匹配3// 2. m multiline（莫体力） 忽略换行匹配 能够多行匹配4// 3. g global (阁楼布偶) 全局匹配56// /A/.test('lalala'); ===&gt;false7// /A/i.test('lalala'); ===&gt;true 元字符详细解析 ^ 开头 $ 结尾 1let reg = /^\\d/ ; //任意数字开头2reg.test('hahaha'); //===&gt;false3reg.test('lalala123'); //===&gt;false4reg.test('20191101hah'); //===&gt;true 1let reg = /\\d$/ ; //任意数字结尾2reg.test('hahaha'); //===&gt;false3reg.test('lalala123'); //===&gt;true4reg.test('20191101hah'); //===&gt;false 1//两个都不加 : 字符串中包含符合规则的就可以2let reg = /\\d+/ ; //包含数字就可以3reg.test('hahaha'); //===&gt;false4reg.test('lalala123'); //===&gt;true5reg.test('20191101hah'); //===&gt;true67//两个都加 : 字符串只能和规则一致8let reg1 = /^\\d+$/; //之能是以数字开头 数字结尾 的数字910//验证手机号码11let reg2 = /^1\\d&#123;10&#125;$/;//只能以1开头 以数字结尾 中间是0~9之间的数 出现10次 \\ 1//把特殊符号转换为 普通 符号 x|y 1let reg1 = /^18|19$/;2reg.test('18'); //===&gt;true3reg.test('19'); //===&gt;true4reg.test('189'); //===&gt;true5reg.test('119'); //===&gt;true6reg.test('81'); //===&gt;false7reg.test('819'); //===&gt;true8//-------------直接使用会存在很乱的优先级问题 一般写的时候一般都伴随着（） 因为小括号会改变处理的优先级 --&gt; 小括号： 分组9let reg1 = /^18|19$/;10reg.test('18'); //===&gt;true11reg.test('19'); //===&gt;true12reg.test('189'); //===&gt;false [] 1//1.中括号中出现的字符一般都代表本身的含义2//2.中括号中不存在多位数 常用的正则表达式 常用的有效数字 1有效数字: 0 1 12 0.2 -1 -12.32 /*3 * 规则分析4 * 1.可能出现 - + 号5 * 2.一位0~9都可以，多位首位不能是06 * 3.小数部分可有可无，有的话必须有小数点和数字7 */8let reg = /^[+-]?(\\d|([1-9]\\d+))(\\.\\d+)?$/; 验证密码 1// 字母、数字、下划线2// 长度 ： 6~16位3let reg = /^\\w&#123;6,16&#125;$/; 4reg.test(val)//返回true代表符合规则 false不符合规则 验证真实姓名 1/*2 * 1.汉字 /^[\\u4E00-\\u9FA5]$/3 * 2.名字长度 2~104 * 3.可能有译名 XX·XXX '尼古·哈哈'5 * 4.可能有少数民族名字 2~106 */7let reg = /^[\\u4E00-\\u9FA5]&#123;2,10&#125;(·[\\u4E00-\\u9FA5]&#123;2,10&#125;)&#123;0,2&#125;$/; 验证邮箱 12/*3 * 1.@符号前 \\w+((-\\w+)|(\\.\\w+))*4 * 1.1.以数字 字母 下划线 开头 1到多位5 * 1.2.还可以是 - 数字 字母 下划线 或者 .数字 字母 下划线 整体出现 0 到 多次6 * 邮箱名：由 数字 字母 下划线 . - 组成 切必须以 数字 开头 -/. 不能连续出现7 * 2.[A-Za-z0-9]+ @xxx.com8 * 2.1.@后紧跟着 数字 字母 1到多位9 * 3.((\\.|-)[A-Za-z0-9]+)* xxx@xxx.[com].cn 匹配com 对@后面名字的补充10 * 3.1.11 * 4.\\.[A-Za-z0-9]+ .cn .com ...12 */13let reg = /^\\w+((-\\w+)|(\\.\\w+))*@[A-Za-z0-9]+((\\.|-)[A-Za-z0-9]+)*\\.[A-Za-z0-9]+$/; 身份证号码 1/*2 * 1.一共18位3 * 2.最后一位可能是X X代表的是104 * 身份证前六位意义： 省 市 县5 * 中间八位意义： 年 月 日6 * 最后四位意义： 最后一位 X或者数字 7 * 倒数第二位： 偶数是 女 基数是 男8 * 其余位数是经过算法算出来的9 */10//let reg = /^\\d&#123;17&#125;(\\d|X)$/;不用11//小括号作用 ： 1. 分组捕获 不仅可以把大正则匹配的信息捕获到，还可以单独捕获到每个小分组的内容 2.改变优先级12let reg = /^(\\d&#123;6&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d)(\\d|X)$/;13reg.exec('4114121198902034432') //捕获结果是一个数组 #### **正则表达式捕获的懒惰性** 实现正则捕获的方法 懒惰性的解决办法 正则RegExp.prototype上的方法 exec 1/*2 * 基于exec实现正则的捕获3 * 1. 捕获到的结果是null / 一个数组 第一项捕获到的是内容 其余项 对应小分组本次单独捕获到的内容 index项 当前捕获到的 在原字符串的起始索引 input项 原始字符串4 * 2.每执行一次 exec只能捕获到一个符合正则规则的 默认情况下 即使多次捕获 捕获的结果永远是第一个 即=&gt;正则的懒惰性 默认只捕获一个5 * 6 * lastIndex代表当前正则下一次匹配的起始索引位置 console.log(reg.lastIndex); ===0 7 * 正则懒惰性的原因就是因为lastIndex默认情况下是不会被修改/改变的 每次都是从起始位置开始查找 lastIndex不能手动修改不行 只能使用全局修饰符 g /\\d+/g 匹配后lastIndex值会自动改变 8 */ 1//需求：编写一个方法execAll()，执行一次可以把所有匹配的结果捕获到（前提：正则一定要设置全局修饰符 g）23function()&#123;4 function execAll(str)&#123;5 // str ： 是要匹配的字符串6 // this ：RegExp的实例（当前操作的正则）7 // 首先验证传进来的正则是否设置了全局修饰符 g 如果没有 则不进行捕获 8 if(!this.global) return this.exec(str);9 // arr : 存储最后所有捕获的信息10 // res ：存储每次捕获的内容 11 let arr = [];12 let res = this.exec(str);13 while(res)&#123;14 //把每次捕获的数组的第一项内容放到数组arr中15 arr.push(res[0]);16 //只要捕获的内容部位null 则继续捕获17 res = this.exec(str);18 &#125;19 return arr === 0 ？ null : arr;20 &#125;21 RegExp.prototype.execAll=execAll;22&#125;();23let reg = /\\d+/g;24console.log(reg.execAll(str)); test 字符串String.prototype上支持正则表达式处理的方法 replace match 1// 字符串.match(正则); 返回所有匹配的数 以数组的形式返回 即 返回 所有符合正则的 项 的数组 如果一项都没有匹配 则返回null2// match 可以在执行一次的情况下 捕获到所有匹配的数据 ( 前提 ：正则需要加全局修饰符 g )34// 上面那些代码 就是 match 实现原理 splite …… 1//实现正则匹配的前提是：当前正则要和字符串匹配 如果不匹配 （exec）捕获的是null 正则的分组捕获1/*2 * ?: =&gt;只匹配不捕获 如果设置了分组 又不想捕获到 就需要加 `？:` 来处理3 */4let reg=/^(\\d&#123;6&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)\\d&#123;2&#125;(\\d)(？:\\d|X)$/;5let str='411411199801224422';6console.log(str.match(reg)); 7//返回发结果 ：[\"411411199801224422\", \"411411\", \"1998\", \"01\", \"22\", \"2\", index: 0, input: \"411411199801224422\", groups: undefined] 1/* 2 * ===&gt; 获取自己想要的数据3 * 多次匹配时 只能捕获到大正则匹配到的数据 小分组的信息拿不到4 * 解决方案5 */6let str = '&#123;1993&#125;年&#123;03&#125;月&#123;23&#125;日';7let reg = /\\&#123;(\\d+)\\&#125;/g;8let aryBig = [];9let arySmall = [];10let res=reg.exec(str);11while(res)&#123;12 let [big,small] = res;13 aryBig.push(big);14 arySmall.push(small);15 res=res.exec(str);16&#125;17console.log(aryBig,arySmall);18// 执行结果为 ：aryBig==&gt;['&#123;1993&#125;','&#123;03&#125;','&#123;23&#125;'] arySmall==&gt;['1993','03','23'] 分组的第三个作用 : 分组引用 1// 分组的第三个作用 : 分组引用2let str = 'book'; //'good' 'look' 'moon' 'foot' ......3let reg = /^[a-zA-Z]([a-zA-Z])\\1[a-zA-Z]$/; //分组引用 ： 就是通过 '\\数字' 让其代表和对应分组出现一模一样的内容4console.log(reg.test('book'));//==&gt;true5console.log(reg.test('deep'));//==&gt;true6console.log(reg.test('some'));//==&gt;false 正则捕获的贪婪性1/*2 * =&gt;正则捕获的贪婪性 ：默认情况下 正则捕获的时候 是按照当前正则所匹配的最长结果来获取的3 * 4 */5let str = '啦啦啦2019&amp;&amp;加油2020';6let reg = /\\d+/g;7console.log(str.match(reg));//===&gt;[\"2019\", \"2020\"]89//----解决办法 ： ==&gt;在量词元字符后面加上一个 `？` 表示取消正则的贪婪性(按照正则匹配的最短结果来获取)----10let str = '啦啦啦2019&amp;&amp;加油2020';11let reg = /\\d+?/g;12console.log(str.match(reg));//[\"2\", \"0\", \"1\", \"9\", \"2\", \"0\", \"2\", \"0\"] ？在正则中的 五大作用 ?左边是非量词元字符 ：本身代表量词元字符 出现0到1次 ?左边是量词 元字符 ： 取消捕获时候的贪婪性 (?:) : 值匹配不捕获 (?=) : 正向预查 (?!) : 负向预查 其他正则捕获的方法 test也能捕获 (本意是匹配) 一般不用 了解就好 1let str = '&#123;2019&#125;年&#123;11&#125;月&#123;2日&#125;'；2let reg = /\\&#123;(\\d+)\\&#125;/g;3console.log(reg.test(str));//==&gt;true4console.log(RegExp.$1);//==&gt;201956console.log(reg.test(str));//==&gt;true7console.log(RegExp.$1);//==&gt;1189console.log(reg.test(str));//==&gt;true10console.log(RegExp.$1);//==&gt;21112console.log(reg.test(str));//==&gt;false13console.log(RegExp.$1);//==&gt;'2' 存储的是上次捕获的结果14//RegExp.$1~$9 : 获取当前本次正则匹配后 第一个到第九个分组的信息 replace 字符串中实现替换的方法 (一般都是伴随正则一起使用的) 重点 1let str = 'jiege@2019|jiege@2020';2// ==&gt;把 'jiege' 转换为 '杰哥'3// 1. 不使用正则 执行一次只能替换一个4str=str.replace('jiege','杰哥');5console.log(str);//==&gt;'杰哥@2019|jiege@2020'67//2. 使用正则 一次就可以完成所有匹配8str=str.replace(/jiege/g,'杰哥');9console.log(str);//==&gt;'杰哥@2019|杰哥@2020'1011// 必须使用正则 不然不好弄1213//不使用正则 每次替换从头开始 类似于正则的懒惰性14str=str.replace('jiege','jiegehaobang').replace('jiege','jiegehaobang');15console.log(str);//==&gt;'jiegehaobanghaobang@2019|jiege@2020'1617//使用正则18str=str.replace(/jiege/g,'jiegehaobang');19console.log(str);//==&gt;'jiegehaobang@2019|jiegehaobang@2020' 案例1：把时间字符串进行处理 1let time = '2019-11-02';2//变为 ==&gt; 2019年11月02日3let reg = /^(\\d&#123;4&#125;)-(\\d&#123;1,2&#125;)-(\\d&#123;1,2&#125;)$/;4time = time.replace(reg,'$1年$2月$3日');5console.log(time)//==&gt;\"2019年11月02日\" replace 实现原理 [str].replace([reg],[function]) 1let time = '2019-11-02';2//变为 ==&gt; 2019年11月02日3let reg = /^(\\d&#123;4&#125;)-(\\d&#123;1,2&#125;)-(\\d&#123;1,2&#125;)$/;45// 实现原理 [str].replace([reg],[function])6// 1.replace 首先拿reg和time进行匹配捕获，能匹配到几次就会把传递的函数执行几次 （而且是 匹配一次就执行一次）7// 2.不仅把方法执行了，而且replace还给方法传递了实参信息(是 exec捕获 的内容一致的信息：大正则匹配的信息 小分组匹配的系信息......)8// 3.在函数中 返回的是什么，就把当前大正则匹配的内容替换成什么910/*time = time.replace(reg,(big,$1,$2,$3)=&gt;&#123;11 //$1,$2,$3是自己设置的变量12 console.log(big,$1,$2,$3);//==&gt;2019-11-02 2019 11 0213&#125;)*/1415time = time.replace(reg,(...arg)=&gt;&#123;16 let [,$1,$2,$3]=arg;17 $2.length &lt; 2 ? $2 = `0$&#123;$2&#125;` : null;18 $3.length &lt; 2 ? $3 = `0$&#123;$3&#125;` : null;19 return `$&#123;$1&#125;年$&#123;$2&#125;月$&#123;$3&#125;日`20&#125;)21console.log(time);//==&gt;'2019年11月02日' 案例2：单词首字母大写 1let str = 'good good study,day day up!';2let reg = /\\b([a-zA-Z])[a-zA-Z]*\\b/g;3//=&gt;函数执行了6次，每一次都把正则匹配到的信息传递给函数4//=&gt;每一次arg存的都是一个数组：['good','g']......5str = str.replace(reg,(...arg)=&gt;&#123;6 let [content,$1]=arg;7 $1 = $1.toUpperCase();8 content = content.substring(1);9 return $1+content;10&#125;)11console.log(str); 案例3：验证一个字符串中那个字母出现的次数最多，多少次？ ​ 做法1： 1/*======去重思维=====*/2let str = '2019nianshayemeiganchneg';3//创建一个对象用来存放字符串的每一个不同的项4let obj = &#123;&#125;;5//将字符串中的每一项都放在对象中6[].forEach.call(str,char=&gt;&#123;7 //判断对象中有没有这个字符，有就把值加一 没有就赋值为一8 if(typeof obj[char]!=='undefined')&#123;9 obj[char]++;10 return;11 &#125;12 obj[char]=1;13&#125;)14let max = 1;15//储存次数最多的字符的数组16let res = [];17//判断出现次数最多的字符出现的次数18for(let key in obj)&#123;19 let item = obj[key];20 item &gt; max ? max = item : null;21&#125;22//判断出现次数最多的字符23for(let key in obj)&#123;24 let item = obj[key];25 if(item === max)&#123;26 res.push(key);27 &#125;28&#125;29console.log(res,max) //[\"n\"] 4 ​ 做法2： 1/*======排序=====*/2let str = '2019nianshayemeiganchnega';34str=str.split('').sort((a,b)=&gt;a.localeCompare(b)).join('');5console.log(str)//0129aaaceeegghhiimnnnnsy6let reg = /([a-zA-Z0-9])\\1+/g;7let ary = str.match(reg);8console.log(str.match(reg));//[\"aaaa\", \"eee\", \"gg\", \"hh\", \"ii\", \"nnnn\"]9ary.sort((a,b)=&gt;b.length - a.length);//sort()数组排序10console.log(ary.sort((a,b)=&gt;b.length - a.length));//[\"aaaa\", \"nnnn\", \"eee\", \"gg\", \"hh\", \"ii\"]11console.log(`出现最多的是$&#123;ary[0].slice(0,1)&#125;,出现了$&#123;ary[0].length&#125;`);//出现最多的是n,出现了412let max = ary[0].length;13let res = [ary[0].substr(0,1)];14for (let i = 1; i &lt; ary.length; i++) &#123;15 let item = ary[i];16 if (item.length&lt;max) &#123;17 break;18 &#125;19 res.push(item.slice(0,1));20&#125;21console.log(max,res); ​ 做法3：*代码最少 推荐 * 1/*======从最大到最小去找--正则匹配=====*/2let str = '2019nianshayemeiganchnega';34//把字符串变成数5str = str.split('').sort((a, b) =&gt; a.localeCompare(b)).join(''); //字母的比较不能用加减 只能用a.localeCompare(b)6//接收最大值7let max = 0;8let res = [];9let flag = false;10console.log(str); //0129aaaaceeegghhiimnnnnsy11for (let i = str.length; i &gt; 0; i--) &#123;12 let reg = new RegExp('([a-zA-Z])\\\\1&#123;' + (i - 1) + '&#125;', 'g');13 str.replace(reg, (content, $1) =&gt; &#123;14 res.push($1);15 max = i;16 flag = true;17 &#125;);18 if (flag) &#123;19 break;20 &#125;21&#125;22console.log(`出现次数最多的字符为$&#123;res&#125;,出现了$&#123;max&#125;次`); ​ 做法4：查找字母删减去重法 案例4：正则表达式 之 时间字符串格式化 1~ function () &#123;2 /**3 * formatTime:时间字符串的格式化处理方法4 * @param &#123;String&#125; templete 期望获取的日期格式模板5 * 模板规则：&#123;0&#125; -&gt;&#123;0~5&#125;-&gt;年月日时分秒6 * @returns &#123;String&#125; 格式化后的时间字符串7 */8 function formatTime(templete = '&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒') &#123;9 //先获取时间字符串中的年月日时分秒等信息10 let timeAry = this.match(/\\d+/g);11 console.log(timeAry); //[\"2019\", \"8\", \"13\", \"16\", \"51\", \"3\"]12 return templete = templete.replace(/\\&#123;(\\d+)\\&#125;/g, (content, $1) =&gt; &#123;13 //content : 代表当前本次大正则匹配的信息 $1代表小粉猪单独匹配的信息14 //以$1的值为索引，到timeary中找到对应的时间(如果没有 用'00'代替)15 let time = timeAry[$1] || '00';16 time.length &lt; 2 ? time = `0$&#123;time&#125;` : null;17 return time;18 &#125;);19 &#125;20 /* 扩展到内置类String.prototype上 */21 ['formatTime'].forEach(item =&gt; &#123;22 String.prototype[item] = eval(item);23 &#125;)24&#125;();2526let time = '2019-8-13 16:51:3';27// 服务器获取的时间数据 ：2019-8-13 16:51:3 2019/8/13 16:51:328// 想要转变的格式 ：'08月13日 16时51分' '2019年08月13日' ......2930// 如果想要[time.formatTime()]这样调用，则方法必须在字符串的原型上31time.formatTime();32time.formatTime('&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日'); //\"2019年08月13日\"33time.formatTime('&#123;0&#125;/&#123;1&#125;/&#123;2&#125;');//\"2019/08/13\"34time.formatTime('&#123;0&#125;-&#123;1&#125;-&#123;2&#125; &#123;3&#125;:&#123;4&#125;:&#123;5&#125;');//\"2019-08-13 16:51:03\" ​ 案例4：正则表达式之qureyURLParams 1~ function () &#123;2 /**3 * qureyURLParams:获取url地址问号后面的参数系信息（可能包含hash值）4 * @param5 * @return6 * [object]把所有问号参数信息以键值对的方式存储起来并返回7 */8 function qureyURLParams() &#123;9 let obj = &#123;&#125;;10 this.replace(/([^=#&amp;?]+)=([^=#&amp;?]+)/g, (...[, $1, $2]) =&gt; obj[$1] = $2);11 this.replace(/#([^=#&amp;?]+)/g, (...[, $1]) =&gt; obj['HASH'] = $1);12 return obj;13 &#125;14 /* 扩展到内置类String.prototype上 */15 ['qureyURLParams'].forEach(item =&gt; &#123;16 String.prototype[item] = eval(item);17 &#125;)18&#125;();1920let url = 'https://www.baidu.com/s?wd=dnf&amp;rsv_spt=1';21url.qureyURLParams(); ​ 案例4：正则表达式之千分符 1~ function () &#123;2 /**3 * millimeter:实现大数字的千分符处理4 * @param5 * @return6 * [String] 千分符后的字符串7 */8 function millimeter() &#123;9 return this.replace(/\\d&#123;1,3&#125;(?=(\\d&#123;3&#125;)+$)/g, content =&gt;content + ',');10 &#125;11 /* 扩展到内置类String.prototype上 */12 ['millimeter'].forEach(item =&gt; &#123;13 String.prototype[item] = eval(item);14 &#125;)15&#125;();1617let num = '123445112'; //=&gt;'112,212,323,123'18num.millimeter(); 注意：部分文章可能会在不就的将来更新 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.blog.geyunjie.com/tags/javascript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://www.blog.geyunjie.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"docsify的基本使用","date":"2018-02-15T04:11:17.000Z","path":"2018/02/15/docsify/","text":"官网https://docsify.js.org/#/zh-cn/quickstart 快速开始初始化项目1//找一个感觉的文件夹23//安装doscify-cli工具4npm i docsify-cli -g56//初始化项目7docsify init ./docs89//启动项目 默认占用3000端口10docsify serve ./docs 配置 插件 具体的看文档就好了 文档写的很详细 此时，问题就完美解决了 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"docsify","slug":"docsify","permalink":"http://www.blog.geyunjie.com/tags/docsify/"}]},{"title":"盒子的垂直水平居中的几种方式","date":"2018-02-14T16:00:00.000Z","path":"2018/02/15/divCenter/","text":"准备工作首先，在做之前，咱们先来分析一下我们要做的是什么？ 一个盒子，垂直 水平 居中 首先 有居中 就必定会被一个父容器（盒子）包裹。 其次 要居中的盒子不会超出父容器大小（否则做居中意义就不大了） 然后 要居中的盒子的宽高可以分为两类 1. 具有固定的宽高。 2. 没有固定的宽高 ​ 根据盒子的类型也可分为两类 1.行内快元素inline-block 2. 块级元素block 那么 现在开始吧！ 方式一 (弹性盒模型的方式)html 代码 1&lt;div class=\"box\"&gt;2 &lt;div class=\"container\"&gt;&lt;/div&gt;3&lt;/div&gt; css 代码 1.box&#123;2 height: 100vh;3 display: flex;4 justify-content: center;5 align-items: center;6&#125;7.container&#123;8 width: 200px;9 background-color: aqua;10 height: 200px;11&#125; 效果图 方式二 （绝对定位）html 代码 1&lt;div class=\"box\"&gt;2 &lt;div class=\"container\"&gt;&lt;/div&gt;3&lt;/div&gt; css 代码 1.container &#123;2 width: 200px;3 background-color: red;4 height: 200px;5 margin: auto;6 position: absolute;7 top: 0;8 bottom: 0;9 left: 0;10 right: 0;11&#125; 效果图 注意：由于是使用绝对定位。元素脱离文档流，相对于具有除去static定位以外的其他父级定位去定位的，如果没有父级定位，根据body来定位 方式三（位移transform的translate属性 + 定位）html 代码 1&lt;div class=\"box\"&gt;2 &lt;div class=\"container\"&gt;&lt;/div&gt;3&lt;/div&gt; css代码 1body &#123;2 position: relative;3 height: 100vh;4&#125;56.container &#123;7 width: 200px;8 height: 200px;9 position: absolute;10 top: 50%;11 left: 50%;12 transform: translate(-50%, -50%);13 background-color: blueviolet;14&#125; 效果图 方式四（位移+外边距 + vh）html 代码 1&lt;div class=\"container\"&gt;&lt;/div&gt; css 代码 1.container &#123;2 width: 200px;3 height: 200px;4 margin: 0 auto;5 margin-top: 50vh;6 background-color: blanchedalmond;7 transform: translate(0, -50%)8&#125; 效果图 注意：部分文章可能会在不就的将来更新 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"html，css","slug":"html，css","permalink":"http://www.blog.geyunjie.com/tags/html%EF%BC%8Ccss/"}]},{"title":"设置cookie","date":"2017-11-12T13:23:17.000Z","path":"2017/11/12/set-cookie/","text":"通过js设置cookie的方法我们在前端开发中，通常都需要获取并记录用户的某些操作设置，这样可以使用户下一次访问网站时不用进行重复的调整设置同一个功能。 此次文章中的方法是在前端开发工作中自己随手写的一组通过js设置与获取cookie的方法，能够应用在多说情况下，没做细挖与深究 1var cookie = &#123;2 set:function(key,val,time)&#123;//设置cookie方法3 var date=new Date(); //获取当前时间4 var expiresDays=time; //将date设置为n天以后的时间5 date.setTime(date.getTime()+expiresDays*24*3600*1000); //格式化为cookie识别的时间6 document.cookie=key + \"=\" + val +\";expires=\"+date.toGMTString(); //设置cookie7 &#125;,8 get:function(key)&#123;//获取cookie方法9 /*获取cookie参数*/10 var getCookie = document.cookie.replace(/[ ]/g,\"\"); //获取cookie，并且将获得的cookie格式化，去掉空格字符11 var arrCookie = getCookie.split(\";\") //将获得的cookie以\"分号\"为标识 将cookie保存到arrCookie的数组中12 var tips; //声明变量tips13 for(var i=0;i&lt;arrCookie.length;i++)&#123; //使用for循环查找cookie中的tips变量14 var arr=arrCookie[i].split(\"=\"); //将单条cookie用\"等号\"为标识，将单条cookie保存为arr数组15 if(key==arr[0])&#123; //匹配变量名称，其中arr[0]是指的cookie名称，如果该条变量为tips则执行判断语句中的赋值操作16 tips=arr[1]; //将cookie的值赋给变量tips17 break; //终止for循环遍历18 &#125; 19 &#125;20 return tips;21 &#125;22&#125; 下面简单的说明一下设置与获取的方法，便于前端开发新手用户使用 设置cookie的方法为：cookie.set(key,val,time) key可以理解为cookie的变量名 val可以理解为这个cookie所带有的值 time是cookie的超时时间，单位为天 获取cookie的方法为：cookie.get(key) key就是刚才我们设置时的cookie变量名 我们只需要将函数赋值给新的变量即可调用这个值，例如：var n = cookie.get(key); 方法写的不算复杂，比较适合前端开发新手使用 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！","tags":[{"name":"cookie","slug":"cookie","permalink":"http://www.blog.geyunjie.com/tags/cookie/"}]},{"title":"块级格式化上下文","date":"2017-09-12T13:33:07.000Z","path":"2017/09/12/block/","text":"块级格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域 根据MDN官网介绍 下列方式会创建块格式化上下文： 根元素(&lt;html&gt;) 浮动元素（元素的 float 不是 none） 绝对定位元素（元素的 position 为 absolute 或 fixed） 行内块元素（元素的 display 为 inline-block） 表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值） 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值） 匿名表格单元格元素（元素的 display为 table、``table-row、 table-row-group、``table-header-group、``table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table） overflow 值不为 visible 的块元素 display 值为 flow-root 的元素 contain 值为 layout、content或 paint 的元素 弹性元素（display为 flex 或 inline-flex元素的直接子元素） 网格元素（display为 grid 或 inline-grid 元素的直接子元素） 多列容器（元素的 column-count 或 column-width 不为 auto，包括 ``column-count 为 1） column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。 浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠也只会发生在属于同一BFC的块级元素之间 总结： BFC是一个独立的渲染区域，他规定了在该区域中，常规流块盒的布局 独立=&gt;不同的BFC区域，它们进行渲染的时候 互不干扰 创建了BFC的元素，隔绝了它内部与外部的联系，内部的渲染不会影响到外部 具体规则： ​ 创建BFC的元素：它的自动高度需要计算浮动元素 ​ 创建BFC的元素：它的边框盒不会与浮动元素重叠 ​ 创建BFC的元素：不会和它的子元素进行外边距合并 对于这些规则，下面会使用具体例子加以说明。 这个区域由某个HTML元素创建，常用的 常见的 会在内部创建BFC区域的元素： 根元素（html） 浮动，绝对定位，固定定位元素 overflow不等于visible的块盒 规则特性的示例示例 一 自动高度需要计算浮动元素css代码 1.container&#123;2 background-color: beige;3 &#125;4 .item&#123;5 float: left;6 width: 200px;7 height: 200px;8 margin: 20px;9 background-color: red;10 &#125; html代码 1&lt;body&gt;2 &lt;div class=\"container\"&gt;3 &lt;div class=\"item\"&gt;&lt;/div&gt;4 &lt;div class=\"item\"&gt;&lt;/div&gt;5 &lt;div class=\"item\"&gt;&lt;/div&gt;6 &lt;div class=\"item\"&gt;&lt;/div&gt;7 &lt;div class=\"item\"&gt;&lt;/div&gt;8 &lt;div class=\"item\"&gt;&lt;/div&gt;9 &lt;div class=\"item\"&gt;&lt;/div&gt;10 &lt;div class=\"item\"&gt;&lt;/div&gt;11 &lt;div class=\"item\"&gt;&lt;/div&gt;12 &lt;div class=\"item\"&gt;&lt;/div&gt;13 &lt;/div&gt;14&lt;/body&gt; 可以看出，此时类为container的容器的高度为0，这也就是因为浮动脱离的文档流，形成了BFC，而常规流块盒不会计算浮动元素的高度。 造成了高度坍塌的问题 解决的办法有两个思路（注意：是两个思路，而不是两种解决办法） 使用clear+伪类的方法清除浮动，也就是在最后面添加一个元素清除浮动，撑开元素的高度 css代码 1 .container&#123;2 background-color: beige;3 &#125;45 .item&#123;6 float: left;7 width: 200px;8 height: 200px;9 margin: 20px;10 background-color: red;11 &#125;1213+ .clearfix::after&#123;14 content: \"\";15 display: block;16 clear: both;17 &#125; html代码 1&lt;body&gt;2+ &lt;div class=\"container clearfix\"&gt;3 &lt;div class=\"item\"&gt;&lt;/div&gt;4 &lt;div class=\"item\"&gt;&lt;/div&gt;5 &lt;div class=\"item\"&gt;&lt;/div&gt;6 &lt;div class=\"item\"&gt;&lt;/div&gt;7 &lt;div class=\"item\"&gt;&lt;/div&gt;8 &lt;div class=\"item\"&gt;&lt;/div&gt;9 &lt;div class=\"item\"&gt;&lt;/div&gt;10 &lt;div class=\"item\"&gt;&lt;/div&gt;11 &lt;div class=\"item\"&gt;&lt;/div&gt;12 &lt;div class=\"item\"&gt;&lt;/div&gt;13 &lt;/div&gt;14&lt;/body&gt; 效果： 使用创建BFC区域，因为BFC会计算浮动元素。即 只要能创建BFC都可以解决 根据不同的场景使用不同的方法 这里只是随便列举一个方法 css代码 1.container&#123;2 background-color: beige;3+ position: absolute;4+ /* overflow: hidden;这种方式副作用最小 */5+ /* float: left; */6&#125;7 8.item&#123;9 float: left;10 width: 200px;11 height: 200px;12 margin: 20px;13 background-color: red;14&#125; html代码 1&lt;body&gt;2- &lt;div class=\"container\"&gt;3 &lt;div class=\"item\"&gt;&lt;/div&gt;4 &lt;div class=\"item\"&gt;&lt;/div&gt;5 &lt;div class=\"item\"&gt;&lt;/div&gt;6 &lt;div class=\"item\"&gt;&lt;/div&gt;7 &lt;div class=\"item\"&gt;&lt;/div&gt;8 &lt;div class=\"item\"&gt;&lt;/div&gt;9 &lt;div class=\"item\"&gt;&lt;/div&gt;10 &lt;div class=\"item\"&gt;&lt;/div&gt;11 &lt;div class=\"item\"&gt;&lt;/div&gt;12 &lt;div class=\"item\"&gt;&lt;/div&gt;13 &lt;/div&gt;14&lt;/body&gt; 效果： 例子 二 BFC边框盒不会与浮动元素重叠BFC不会与浮动元素的边框盒重叠，这样会方便我们做很多布局。例如： css代码 1.float&#123;2 width: 200px;3 height: 200px;4 margin: 20px;5 background-color: red;6 float: left;7 &#125;89 .container&#123;10 height: 300px;11 background-color: #008c8c;12 /* overflow: hidden; */13 &#125; html代码 1&lt;body&gt;2 &lt;div class=\"float\"&gt;&lt;/div&gt;3 &lt;div class=\"container\"&gt;&lt;/div&gt;4&lt;/body&gt; 效果： 当把overflow: hidden;的注释打开时，就会在内部创建BFC，渲染的效果如下： 此时如果设置BFC的左外边距的话，只要外边距不超过左边浮动盒子的大小，就是无效的。 因为此时设置做外边距会被左边的浮动元素覆盖。 如果要设置两个盒子的间距的话，需要设置左边浮动盒子的右外边距 margin-right: 100px; 设置后效果如下 根据这个效果，可以做很多一边固定一边自适应的布局，也可以做多边固定，一边自适应。比如：圣杯布局，双飞翼布局，都可以使用这个特性进行布局。 注意：对定位不会有这种特性。原因是：浮动元素不完全脱离常规流。而定位是完全脱离常规流 示例三 BFC不会和它的子元素进行外边距合并BFC不会和它的子元素进行外边距合并，而标准流会进行外边距合并。这就是为什么在布局的时候，会出现外边距合并的原因，以及出现这种问题的时候我们为什么一般都会使用overflow: hidden(不是唯一的)解决外边距合并的根本原因。例如： css代码 1.father&#123;2 background-color: #008c8c;3 height: 500px;4 margin-top: 50px;5&#125;6.son&#123;7 background-color: blueviolet;8 height: 100px;9 margin: 50px;10&#125; html代码 1&lt;div class=\"father\"&gt;2 &lt;div class=\"son\"&gt;3 &lt;/div&gt;4&lt;/div&gt; 效果： 根据代码和效果图可以看出：父盒子与子盒子的外边距进行了合并 给父元素加上overflow：hidden属性后，解决外边距合并后的效果图： 根本原因: ​ 根元素html元素会创建BFC ​ 父元素处于的上下文是根元素创建的BFC上下文 ​ 子元素处于的上下文是父元素创建的BFC上下文 ​ 他们处于不同的BFC上下文，而BFC是独立的渲 ​ 染区域。所以他们两个的渲染是互不干扰的，因此 ​ 他们的外边距是不能合并的 具体代码： css代码： 1.father&#123;2 background-color: #008c8c;3 height: 500px;4 margin-top: 50px;5 + overflow: hidden;6&#125;7.son&#123;8 background-color: blueviolet;9 height: 100px;10 margin: 50px;11&#125; html代码不变 注意：部分文章可能会在不就的将来更新 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"css","slug":"css","permalink":"http://www.blog.geyunjie.com/tags/css/"}]},{"title":"Js的闭包详解","date":"2017-09-12T13:33:07.000Z","path":"2017/09/12/closure-js/","text":"javascript中闭包的工作原理1. 什么是闭包官方”的解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。 相信很少有人能直接看懂这句话，因为他描述的太学术。其实这句话通俗的来说就是：JavaScript中所有的function都是一个闭包。不过一般来说，嵌套的function所产生的闭包更为强大，也是大部分时候我们所谓的“闭包”。 看下面这段代码： 1function fn() &#123; 2 var i = 0; 3 function closure() &#123; alert(++i); &#125; 4 return closure;5&#125;6var clo = fn();7clo(); 这段代码有两个特点： 函数closure嵌套在函数fn内部； 函数fn返回函数closure。 上面这些代码 实际上即创建了 一个闭包。为什么？因为函数fn外的变量clo引用了函数fn内的函数closure. 让我们说的更透彻一些： 所谓“闭包”，就是在构造函数体内定义另外的函数作为目标对象的方法函数，而这个对象的方法函数反过来引用外层函数体中的临时变量。这使得只要目标 对象在生存期内始终能保持其方法，就能间接保持原构造函数体当时用到的临时变量值。尽管最开始的构造函数调用已经结束，临时变量的名称也都消失了，但在目 标对象的方法内却始终能引用到该变量的值，而且该值只能通这种方法来访问。即使再次调用相同的构造函数，但只会生成新对象和方法，新的临时变量只是对应新 的值，和上次那次调用的是各自独立的。 2.闭包有什么作用？ 简而言之，闭包的作用就是在fn执行完并返回后，闭包使得Javascript的垃圾回收机制GC不会收回fn所占用的资源，因为fn的内部函数closure的执行需要依赖fn中的变量。这是对闭包作用的非常直白的描述，不专业也不严谨，但大概意思就是这样，理解闭包需要循序渐进的过程 在上面的例子中，由于闭包的存在使得函数fn返回后，fn中的i始终存在，这样每次执行clo()，i都是自加1后alert出i的值。 那 么我们来想象另一种情况，如果fn返回的不是函数closure，情况就完全不同了。因为fn执行完后，closure没有被返回给fn的外界，只是被fn所引用，而此时fn也只会被closure引 用，因此函数fn和closure互相引用但又不被外界打扰(被外界引用)，函数fn和closure就会被GC回收。(关于Javascript的垃圾回收机制将在后面详细介绍 3. 闭包内的微观世界 如果要更加深入的了解闭包以及函数fn和嵌套函数closure的关系，我们需要引入另外几个概念：函数的执行环境(excution context)、活动对象(call object)、作用域(scope)、作用域链(scope chain)。以函数fn从定义到执行的过程为例阐述这几个概念。 当定义函数fn的时候，js解释器会将函数fn的作用域链(scope chain)设置为定义fn时fn所在的“环境”，如果fn是一个全局函数，则scope chain中只有window对象。 当执行函数fn的时候，fn会进入相应的执行环境(excution context)。 在创建执行环境的过程中，首先会为fn添加一个scope属性，即fn的作用域，其值就为第1步中的scope chain。即fn.scope=fn的作用域链。 然后执行环境会创建一个活动对象(call object)。活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问。创建完活动对象后，把活动对象添加到fn的作用域链的最顶端。此时fn的作用域链包含了两个对象：fn的活动对象和window对象。 下一步是在活动对象上添加一个arguments属性，它保存着调用函数fn时所传递的参数 最后把所有函数fn的形参和内部的函数closure的引用也添加到fn的活动对象上。在这一步中，完成了函数closure的的定义，因此如同第3步，函数closure的作用域链被设置为closure所被定义的环境，即fn的作用域 到此，整个函数fn从定义到执行的步骤就完成了。此时fn返回函数closure的引用给clo，又函数closure的作用域链包含了对函数fn的活动对象的引用，也就是说closure可以访问到fn中定义的所有变量和函数。函数closure被clo引用，函数closure又依赖函数fn，因此函数fn在返回后不会被GC回收。 当函数closure执行的时候亦会像以上步骤一样。因此，执行时b的作用域链包含了3个对象：closure的活动对象、fn的活动对象和window对象，如下图所示： 注意：图片来源于网络 如图所示，当在函数closure中访问一个变量的时候，搜索顺序是： 先搜索自身的活动对象，如果存在则返回，如果不存在将继续搜索函数fn的活动对象，依次查找，直到找到为止。 如果函数closure存在prototype原型对象，则在查找完自身的活动对象后先查找自身的原型对象，再继续查找。这就是Javascript中的变量查找机制。 如果整个作用域链上都无法找到，则返回undefined 总结： 两个重要的词语：函数的定义与执行。文中提到函数的作用域是在定义函数时候就已经确定，而不是在执行的时候确定（参看步骤1和3）。用一段代码来说明这个问题： 1function f(x) &#123; 2 var g = function () &#123; return x; &#125;3 return g;4&#125;5var h = f(1);6alert(h()); 这段代码中变量h指向了f中的那个匿名函数(由g返回)。 假设函数h的作用域是在执行alert(h())确定的，那么此时h的作用域链是：h的活动对象-&gt;alert的活动对象-&gt;window对象。 假设函数h的作用域是在定义时确定的，就是说h指向的那个匿名函数在定义的时候就已经确定了作用域。那么在执行的时候，h的作用域链为：h的活动对象-&gt;f的活动对象-&gt;window对象。 如果第一种假设成立，那输出值就是undefined；如果第二种假设成立，输出值则为1。 运行结果证明了第2个假设是正确的，说明函数的作用域确实是在定义这个函数的时候就已经确定了 4. 闭包的应用场景 保护函数内的变量安全。以最开始的例子为例，函数fn中i只有函数closure才能访问，而无法通过其他途径访问到，因此保护了i的安全性。 在内存中维持一个变量。依然如前例，由于闭包，函数a中i的一直存在于内存中，因此每次执行c()，都会给i自加1。 通过保护变量的安全实现JS私有属性和私有方法（不能被外部访问）私有属性和方法在Constructor外是无法被访问的function Constructor(…) {var that = this;var membername = value;function membername(…) {…}} 以上3点是闭包最基本的应用场景，很多经典案例都源于此。 5. Javascript的垃圾回收机制 在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。因为函数fn被closure引用，closure又被fn外的clo引用，这就是为什么函数fn执行后不会被回收的原因。 理解JavaScript的闭包是迈向高级JS程序员的必经之路，理解了其解释和运行机制才能写出更为安全和优雅的代码。 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.blog.geyunjie.com/tags/javascript/"}]},{"title":"css三大特性","date":"2017-09-12T13:33:07.000Z","path":"2017/09/12/css-properties/","text":"","tags":[{"name":"css","slug":"css","permalink":"http://www.blog.geyunjie.com/tags/css/"}]},{"title":"JavaScript原型","date":"2017-09-12T13:33:07.000Z","path":"2017/09/12/prototype/","text":"总结 原型对象 对象原型 构造函数 之间的关系 以及js的原型链问题这个只是点，想必每个前端程序员都会。具体的不再这多说，请往下看 原型对象 prototype 是构造函数的属性，这个属性是一个对象，称为原型对象 每个函数都有一个prototype原型对象 作用：共享方法，达到节省内存的目的。 如果不共享方法，每次实例化对象就得创建原型链上的所有的方法，浪费内存 对象原型 简称原型 ptoto 作用：指向原型对象 只读属性 只是提供对象的查找机制 每一个对象都有一个原型，作用是指向原型对象prototype 构造函数 constructor 作用：记录是哪个构造函数创建出来的 指向构造函数本身 用来让原型对象重新指向原来的构造函数 ​ js原型链 js的原型链就是js的一个查找规则查找的规则就如上图所属那样通过原型对象 一直往上查找js可以通过原型链 一级一级的向上查找， 直到查找到为止，原型链的最终指向为 null 注意：部分文章可能会在不就的将来更新 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.blog.geyunjie.com/tags/javascript/"}]},{"title":"Html基础知识学习总结","date":"2017-08-15T10:54:07.000Z","path":"2017/08/15/starthtml/","text":"Html基础知识学习总结Html基础标签 &lt;h1&gt;&lt;/h1&gt;:标题&lt;p&gt;&lt;/p&gt; 段落&lt;hr&gt;水平线&lt;br&gt;换行&lt;span&gt;&lt;/span&gt;分区，可多标签一行&lt;div&gt;&lt;/div&gt;分区，每个标签一行 文本格式化标签 加粗 斜体 删除 &lt;/ins 下划线 图像标签 属性 alt 图片不能显示时的替代文本 title 鼠标悬停时显示 height 图像高度 width 图像宽度 border 图像边框宽度 超链接标签 href =url 链接的地址target _blank 新窗口打开 &lt;base&gt; &lt;base target=&quot;_blank&quot;&gt; 设置超链接的共有属性 预格式化文本 &lt;pre&gt; &lt;/pre&gt; 预格式化文本 保留空格与换行 常用特殊字符1空字符 &amp;nbsp;2注册商标 &amp;reg;3&lt; &amp;lt;4&gt; &amp;gt; 5&amp; &amp;amp; 表格表格数据格式1&lt;body&gt;2&lt;!-- 表格标签--&gt;3 &lt;table border=\"1\"&gt;4 &lt;!--表格标题标签 即表头--&gt;5 &lt;caption&gt;表格标题&lt;/caption&gt;6 &lt;!--行标签--&gt;7 &lt;tr&gt;8 &lt;!--表头单元格,文字居中且加粗--&gt;9 &lt;th&gt;&lt;/th&gt;10 &lt;/tr&gt;11 &lt;tr&gt;12 &lt;!--单元格标签--&gt;13 &lt;td&gt;&lt;/td&gt;14 &lt;/tr&gt;15 &lt;/table&gt;16&lt;/body&gt; 表格属性 border 边框width 宽度height 高度align 设置表格在网页中水平对齐方式 left center right cellspacing 单元格与单元格之间距离 cellpadding 单元格内容与边框的距离 合并单元格行 rowspan=”合并单元格的个数 “ 列 colspan=”合并单元格个数” 合并的方式 先确认跨行还是跨列 根据 先上 后下 先左 后右的原则找到目标单元格 ，然后写上合并方式 和合并数量 删除多余的单元格 语义化结构划分1&lt;thead&gt;&lt;/thead&gt; 表的头部 内部必须拥有&lt;tr&gt;标签2&lt;tbody&gt;&lt;/tbody&gt; 表的主体3&lt;tfoot&gt;&lt;/tfoot&gt; 表的末尾4 注意：结构不是必须的 即使不写，绝大多数浏览器在解析的时候，都会智能的给你加上 列表分类 有序列表 无序列表 自定义列表 有序列表1&lt;ol&gt;2 &lt;li&gt;列表项&lt;/li&gt;3 &lt;li&gt;列表项&lt;/li&gt;4&lt;/ol&gt;5注意：实际中很少使用有序列表，在做一些列表的时候，大家都比较喜欢使用无序列表。因为ul标签里面只能嵌套li标签6 一般在使用列表的时候都会去除别表的默认样式，再根据自己的需求去使用css js 去定制自己需要的样式和交互 无序列表1&lt;ul&gt;2 &lt;!--ul内只能嵌套li--&gt;3 &lt;li&gt;列表项1 &lt;/li&gt;4 &lt;li&gt;列表项2&lt;/li&gt;5&lt;/ul&gt;6注意：一般的列表，都喜欢使用 无序列表 自定义列表1&lt;dl&gt;2 &lt;dt&gt;名词&lt;/dt&gt;3 &lt;dd&gt;名词的解释1&lt;/dd&gt;4 &lt;dd&gt;名词的解释2&lt;/dd&gt;5 &lt;dt&gt;名词2&lt;/dt&gt;6 &lt;dd&gt;名词2的解释2&lt;dd&gt;7&lt;/dl&gt;8注意：自定义标签一般都用在页面结尾的友情链接部分 就是 页面的 footer部分 表单 这里写具体的表单标签 // from表单用于提交数据 有action method name属性 表单标签 标签 语法&lt;input type=&quot;属性值&quot;/&gt; 属性值 type text 单行文本输入框 password 密码输入框 radio 单选按钮 checkbox 复选框 button 普通按钮 submit 提交按钮 reset 重置按钮 image 图像形式的提交按钮 file 文件域 name 控件的名称 value input控件中的默认文本值 size input控件在页面中的显示宽度 checked 表示默认选中状态 &lt;label&gt;&lt;/label&gt;标签 用户名： 用户名： &lt;textarea&gt;&lt;/textarea&gt; 文本域select下拉列表1&lt;select&gt;2 &lt;option&gt;--请选择--&lt;/option&gt;3 &lt;!--添加默认选中项--&gt;4 &lt;option selected=\"selected\"&gt;选项１&lt;/option&gt;5 &lt;option&gt;选项２&lt;/option&gt;6&lt;/select&gt; 注意：部分文章可能会在不就的将来更新 如果能够帮助到你，是小编最大的荣幸 当然 有 不好的地方 请大家帮忙指出 学习永无止境 小编一直认为 人外有人 天外有天 一起学习 共同进步 让我们共同加油吧！！！","tags":[{"name":"html","slug":"html","permalink":"http://www.blog.geyunjie.com/tags/html/"}]}]